<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../transforms/pp2html.xsl"?>
<?xml-model href="https://github.com/commoncriteria/transforms/raw/master/schemas/CCProtectionProfile.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>


<!-- for a PP-module -->
<!-- <?xml-model href="../transforms/schemas/CCModule.rng" type="application/xml" 
                  schematypens="http://relaxng.org/ns/structure/1.0"?>
-->

<!-- For PP or cPP -->
<!-- Name of the TOE product  -->
<!-- Plural name of the TOE product (optional)  -->
<!-- Whether to use boilerplate text by default (can be disabled in sections) -->
<!-- A short name for the PP (e.g. App or MDF) -->
<PP target-product="Full Drive Encryption - EE" 
  xmlns="https://niap-ccevs.org/cc/v1"
  xmlns:cc="https://niap-ccevs.org/cc/v1"
  xmlns:sec="https://niap-ccevs.org/cc/v1/section"
  xmlns:h="http://www.w3.org/1999/xhtml" 
  boilerplate='yes'>
<cPP/>

<!-- for FP -->
<!--
<Package name="TLS"                                   
    xmlns="https://niap-ccevs.org/cc/v1"
    xmlns:h="http://www.w3.org/1999/xhtml"
    xmlns:sec="https://niap-ccevs.org/cc/v1/section"
-->

<!-- For a PP-Module 
<Module
    name="Widget Clients"                              # Name of the Module  
    xmlns="https://niap-ccevs.org/cc/v1"               # Some html magic
    xmlns:h="http://www.w3.org/1999/xhtml"             # uses the "h" namespace for inline HTML
    xmlns:sec="https://niap-ccevs.org/cc/v1/section"   # The "sec" namespace for sections is available
    target-product="Widget"                            # Name of the TOE product
    target-products="Widgets"                          # Plural name of the TOE product (optional)
    boilerplate="yes"                                  # Whether to use boilerplate text by default (can be disabled in sections)
    short="Wid">                                       # A short name for the PP (e.g. App or MDF)
-->

  <!-- PPReference (all documents) -->
  <PPReference>
    <ReferenceTable>
      <PPTitle>collaborative Protection Profile for Full Drive Encryption – Encryption Engine</PPTitle>
      <PPVersion>3.0</PPVersion>
      <PPAuthor>Full Disk Encryption international Technical Community</PPAuthor>
      <PPPubDate>2025-05-30</PPPubDate>
      <Keywords>Full Drive Encryption – Encryption Engine</Keywords>               <!-- This field is unused and optional -->
    </ReferenceTable>
  </PPReference>

<!-- Revision History (all documents) -->
  <RevisionHistory>
    <entry>
      <version>Round 0.1</version>
      <date>2014-08-26</date>
      <subject>Initial release for iTC review</subject>
    </entry>
    <entry>
      <version>0.2</version>
      <date>2014-09-05</date>
      <subject>Draft published for public review</subject>
    </entry>
    <entry>
      <version>0.13</version>
      <date>2014-10-17</date>
      <subject>Incorporated comments received from the public review</subject>
    </entry>
    <entry>
      <version>1.0</version>
      <date>2015-01-26</date>
      <subject>Incorporated comments received from the CCDB review</subject>
    </entry>
    <entry>
      <version>1.5</version>
      <date>2015-09-02</date>
      <subject>Revised based on additional use cases developed by iTC</subject>
    </entry>
    <entry>
      <version>2.0</version>
      <date>2016-09-09</date>
      <subject>Incorporated comments received from the public review, and also
        updated the Key Destruction section and AVA_VAN.</subject>
    </entry>
    <entry>
      <version>2.0 + Errata 20190201</version>
      <date>2019-02-01</date>
      <subject>Updated to reflect CC Part 3 evaluation findings and FDE
        Interpretation Team [FIT] rulings</subject>
    </entry>
    <entry>
        <version>3.0</version>
        <date>2025-05-30</date>
        <subject>Updated for CC:2022, reviewing and applying modifications to the PP</subject>
      </entry>
  </RevisionHistory>

<!-- PP Preferences (all documents) -->
<pp-preferences>
     <!-- Indicate that audit events are defined with their SFRs -->
	 <!-- All new documents should do it this way. This will become the default, if it hasn't already.  -->
	 <!-- And this preference might not even be necessary. I should test it. -->
              
	 
	 <!-- Indicates that audit events will be displayed along the associated SFR in the published document -->
	 <!-- rather than in an audit table. -->
<!--     <display-audit-with-sfrs/>     -->

	 <!-- Indicates that the document is using CC:2022. -->
	 <!-- This setting has already been deprecated, but is still allowed for backward compatiblity -->
	 <!-- New douments shoudl use the <CClaimsInfo> element to specify CC:2022 --> 
 <suppress-niap-logo/>
  </pp-preferences>


  <!-- Introduction (all documents) -->
  <!-- Introduction (all documents) -->
  <section title="Introduction" id="sec-intro">

    <!-- PP or TOE Overview -->

    <section title="PP Overview" id="sec-ppoverview">
      	The purpose of the first set of Collaborative Protection Profiles (cPPs) for Full Drive
      	Encryption (FDE): Authorization Acquisition (AA) and Encryption Engine (EE) is to provide
      	requirements for Data-at-Rest protection for a lost device that contains storage. These cPPs
      	allow FDE solutions based in software and/or hardware to meet the requirements. The form
      	factor for a storage device may vary, but could include: system hard drives/solid state
      	drives in servers, workstations, laptops, mobile devices, tablets, and external media. A
      	hardware solution could be a Self-Encrypting Drive or other hardware-based solutions; the
      	interface (USB, SATA, etc.) used to connect the storage device to the host machine is outside
      	the scope of this cPP.<h:br/><h:br/>
        
        Full Drive Encryption encrypts all data (with certain exceptions) on the storage device and 
        permits access to the data only after successful authorization to the FDE solution. The 
        exceptions include the necessity to leave a portion of the storage device (the size may vary
        based on implementation) unencrypted for such things as the Master Boot Record (MBR) or other
        AA/EE pre-authentication software. These FDE cPPs interpret the term “full drive encryption” 
        to allow FDE solutions to leave a portion of the storage device unencrypted so long as it 
        contains plaintext user or plaintext authorization data.<h:br/><h:br/>
        
        Since the FDE cPPs support a variety of solutions, two cPPs describe the requirements for the
        FDE components shown in Figure 1.  
        
        <h:p><figure entity="images/fde-components.png" title="FDE Components" id="toe"/></h:p>

          The FDE cPP - Authorization Acquisition describes the requirements for the Authorization Acquisition
          piece and details the necessary security requirements and assurance activities necessary to interact with a user 
          and result in the availability of a Border Encryption Value (BEV).<h:br/><h:br/>
          The FDE cPP - Encryption Engine describes the requirements for the Encryption Engine piece and details
          the necessary security requirements and assurance activities for the actual encryption and
          decryption of the data by the DEK. Each cPP will also have a set of core requirements for management
          functions, proper handling of cryptographic keys, updates performed in a trusted manner, audit and self-tests.<h:br/><h:br/> 
          This TOE description defines the scope and functionality of the Encryption Engine, and
          the Security Problem Definition describes the assumptions made about the operating
          environment and the threats to the EE that the cPP requirements address.
	</section>  <!-- PP Overview -->
	
	<!-- CC and Tech terms.  -->
	<!-- CC terms are auto-generated -->
	<!-- All tech terms are generated from the list below. -->
	<!-- You should add and delete tech terms as required by the technology type. -->
	<tech-terms>
	  <!-- To remove an irrlevant CC term from the document, use the <suppress> element -->
      <suppress>Distributed TOE</suppress>   
      <term abbr='AA' full="Authorization Acquisition"></term>
      <term full="Advanced Encryption Standard" abbr="AES"></term>
      <term full="Assurance">Grounds for confidence that a TOE meets the SFRs [CC1].</term>
      <term full="Authorization Factor">A value that a user knows, has, or is (e.g. password, token, etc.)
        submitted to the TOE to establish that the user is in the community
        authorized to use the hard disk. This value is used in the derivation or
        decryption of the BEV and eventual decryption of the DEK. Note
        that these values may or may not be used to establish the particular
        identity of the user. </term>
        
      <term abbr='BEV' full="Border Encryption Value">A value passed from the FDE Authorization
        Acquisition (AA) to the FDE Encryption Engine (EE) intended to link the key chains
        of the two components.</term>
      <term abbr='BIOS' full="Basic Input Output System"></term>
      


      <term abbr='CBC' full="Cipher Block Chaining"></term>
      <term abbr='CC' full="Common Criteria"></term>
      <term abbr='CCM' full="Counter with CBC-Message Authentication Code"></term>
      <term abbr='CEM' full="Common Evaluation Methodology"></term>
      <term abbr='CPP' full="Collaborative Protection Profile"></term>
      <term abbr='DEK' full="Data Encryption Key">A key used to encrypt data-at-rest.</term>
      <term abbr='DRBG' full="Deterministic Random Bit Generator"></term>
      <term abbr='DSS' full="Digital Signature Standard"></term>
      <term abbr='ECC' full="Elliptic Curve Cryptography"></term>
      <term abbr='ECDSA' full="Elliptic Curve Digital Signature Algorithm"></term>
      <term abbr='EE' full="Encryption Engine"></term>
      <term abbr='EEPROM' full="Electrically Erasable Programmable Read-Only Memory"></term>
      <term abbr='FIPS' full="Federal Information Processing Standards"></term>
      <term abbr='FDE' full="Full Drive Encryption">Refers to partitions of logical blocks of user accessible data as
        managed by the host system that indexes and partitions and an
        operating system that maps authorization to read or write data to blocks
        in these partitions. For the sake of this Security Program Definition
        (SPD) and cPP, FDE performs encryption and authorization on one
        partition, so defined and supported by the OS and file system jointly,
        under consideration. FDE products encrypt all data (with certain
        exceptions) on the partition of the storage device and permits access to
        the data only after successful authorization to the FDE solution. The
        exceptions include the necessity to leave a portion of the storage device
        (the size may vary based on implementation) unencrypted for such
        things as the Master Boot Record (MBR) or other AA/EE preauthentication software. These FDE cPPs interpret the term “full drive
        encryption” to allow FDE solutions to leave a portion of the storage
        device unencrypted so long as it contains no protected data.</term>
      <term abbr='FFC' full="Finite Field Cryptography"></term>
      <term abbr='GCM' full="Galois Counter Mode"></term>
      <term abbr='HMAC' full="Keyed-Hash Message Authentication Code"></term>
      <term abbr='HW' full="Hardware"></term>
      <term abbr='IEEE' full="Institute of Electrical and Electronics Engineers"></term>
      <term full="Host Platform">The local hardware and software the TOE is running on, and does not
        include any peripheral devices (e.g. USB devices) that may be
        connected to the local hardware and software.</term>
      <term full="Intermediate Key">A key used in a point between the initial user authorization and the
        DEK.</term>
      <term abbr='IT' full="Information Technology"></term>
      <term abbr='ITSEF' full="IT Security Evaluation Facility"></term>
      <term abbr='ISO/IEC' full="International Organization for Standardization / International Electrotechnical Commission"></term>
      <term abbr='IV' full="Initialization Vector"></term>
      <term abbr='KEK' full="Key Encryption Key">A key used to encrypt other keys, such as DEKs or storage that
        contains keys.</term>
        <term full="Key Chaining">The method of using multiple layers of encryption keys to protect data.
          A top layer key encrypts a lower layer key which encrypts the data;
          this method can have any number of layers.</term>
          <term full="Key Material">Key material is commonly known as critical security parameter (CSP)
            data, and also includes authorization data, nonces, and metadata.</term>
      <term full="Key Sanitization">A method of sanitizing encrypted data by securely overwriting the key
          that was encrypting the data.</term>
      <term abbr='KMD' full="Key Management Description"></term>
      <term abbr='KRK' full="Key Release Key">A key used to release another key from storage, it is not used for the
        direct derivation or decryption of another key.</term>
      <term abbr='MBR' full="Master Boot Record"></term>
      <term abbr='NIST' full="National Institute of Standards and Technology"></term>
      <term full="Non-Volatile Memory">A type of computer memory that will retain information without
        power. 
        </term>
      <term abbr='OS' full="Operating System">Software which runs at the highest privilege level and can directly
        control hardware resources.</term>
      <term abbr='PBKDF' full="Password-Based Key Derivation Function"></term>
      <term full="Powered-Off State">The device has been shut down.</term>
      <term full="Protected Data">This refers to all data on the storage device with the exception of a
        small portion required for the TOE to function correctly. It is all space
        on the disk a user could write data to and includes the operating
        system, applications, and user data. Protected data does not include the
        Master Boot Record or Pre-authentication area of the drive – areas of
        the drive that are necessarily unencrypted.</term>
      <term abbr='PRF' full="Pseudo Random Function"></term>
      <term abbr='RBG' full="Random Bit Generator"></term>
      <term abbr='RNG' full="Random Number Generator"></term>
      <term abbr='RSA' full="Rivest Shamir Adleman Algorithm"></term>
      <term abbr='SAR' full="Security Assurance Requirements"></term>
      <term abbr='SED' full="Self-Encrypting Drive"></term>
      <term abbr='SHA' full="Secure Hash Algorithm"></term>
      <term abbr='SFR' full="Security Functional Requirements"></term>
      <term abbr='ST' full="Security Target"></term>
      <term abbr='SPD' full="Security Problem Definition"></term>
      <term abbr='SPI' full="Serial Peripheral Interface"></term>
      <term full="Submask">A submask is a bit string that can be generated and stored in a number
        of ways.</term>
      <term abbr='TOE' full="Target of Evaluation">A set of software, firmware and/or hardware possibly accompanied by
        guidance. [CC1]</term>
      <term abbr='TPM' full="Trusted Platform Module"></term>
      <term abbr='TSF' full="TOE Security Functionality"></term>
      <term abbr='TSS' full="TOE Summary Specification"></term>
      <term abbr='USB' full="Universal Serial Bus"></term>
      <term abbr='XOR' full="Exclusive or"></term>
      <term abbr='XTS' full="XEX (XOR Encrypt XOR) Tweakable Block Cipher with Ciphertext Stealing"></term>

      
    </tech-terms>    

	<!-- Other sections can be added here. -->
	<!-- Commen examples include Scope of Document, Intended Audiance, Compliant Targets of Evaluation,
	     TOE Boundary, TOE Operational Environment, and Roles. These sections can also be included in the
		 TOE/PP Overview aove. -->
     <section title="Implementation" id="sec-TOEimplementation">
       Full Drive Encryption solutions vary with implementation and vendor combinations.<h:br/><h:br/> 
       Therefore, vendors will evaluate products that provide both components of the Full Disk
        Encryption Solution (AA and EE) against both cPPs – could be done in a single evaluation
        with one ST. A vendor that provides a single component of an FDE solution would only evaluate
        against the applicable cPP. The FDE cPP is divided into two documents to allow labs to
        independently evaluate solutions tailored to one cPP or the other. When a customer acquires
        an FDE solution, they will either obtain a single vendor product that meets the AA + EE cPPs
        or two products, one of which meets the AA and the other of which meets the EE cPPs.<h:br/><h:br/>
       The table below illustrates a few examples for certification<h:br/><h:br/>
        
        <h:head><h:b><ctr ctr-type="Table" pre="Table" id="atref-mandatory">: Examples of cPP Implementations</ctr></h:b></h:head>			
        <h:tr class="header"><h:td>Event</h:td><h:td/></h:tr>    	
  <h:table border='1'>
      <h:tr>
        <h:th>Implementation</h:th>
        <h:th>cPP</h:th>
        <h:th>Description</h:th>
      </h:tr>
          <h:tr>
          
        <h:td>Host</h:td>
        <h:td>AA</h:td>
        <h:td>Host software provides the interface to a self-encrypting drive</h:td>
      </h:tr>
      <h:tr>
        <h:td>Self-Encrypting Drive (SED)</h:td>
        <h:td>EE</h:td>
        <h:td>A self-encrypting drive used in combination with separate host
          software</h:td>
      </h:tr>
      <h:tr>
        <h:td>Software FDE</h:td>
        <h:td>AA + EE</h:td>
        <h:td>A software full drive encryption solution</h:td>
      </h:tr>
      <h:tr>
        <h:td>Hybrid</h:td>
        <h:td>AA + EE</h:td>
        <h:td>A single vendor’s combination of hardware (e.g., hardware encryption engine,
          cryptographic co-processor) and software</h:td>
      </h:tr>
  </h:table>

     </section>
     <section title="TOE Overview" id="sec-TOEoverview">
        The Target of Evaluation (TOE) for this cPP is either the Encryption Engine or a combined
        evaluation of the set of cPPs for FDE (Authorization Acquisition or Encryption Engine).<h:br/><h:br/> 
        
        The following sections provide an overview of the functionality of the FDE EE as well as the security capabilities.

     
     <section title="Encryption Engine Introduction" id="sec-TOEencryption-engine-introduction">
      
      The Encryption Engine objectives focus on data encryption, policy enforcement, and key
      management. The EE is responsible for the generation, update, archival, recovery, protection,
      and destruction of the DEK and other intermediate keys under its control. The EE receives a
      BEV from the AA. The EE uses that BEV for the decryption of the DEK although other
      intermediate keys may exist in between those two points. Key encryption keys (KEKs) wrap
      other keys, notably the DEK or other intermediary keys which chain to the DEK. Key releasing
      keys (KRKs) authorize the EE to release either the DEK or other intermediary keys which chain
      to the DEK. These keys only differ in the functional use.<h:br/><h:br/>
      
      The EE determines whether to allow or deny a requested action based on the KEK or KRK
      provided by the AA. Possible requested actions include but are not limited to changing of
      encryption keys, decryption of data, and key sanitization of encryption keys (including the 
      DEK). The EE may offer additional policy enforcement 1 to prevent access to ciphertext or the
      unencrypted portion of the storage device. Additionally the EE may provide encryption support
      for multiple users on an individual basis.<h:br/><h:br/>
       
      Figure 2 illustrates the components within EE and its relationship with AA.
          
      <figure entity="images/fde-encryption_engine.png" title="Encryption Engine Details" id="toe"/>
     </section>
       
     <section title="Encryption Engine Security Capabilities" id="sec-TOEencryption-engine_security_capabilities">
       The Encryption Engine is ultimately responsible for ensuring that the data is encrypted using a
       prescribed set of algorithms. The EE manages the decryption of the data on the storage device
       through decryption of the DEK based on the validity of the BEV provided by the AA. It also
       manages administrative functions, such as changing the DEK, managing the BEVs required for
       decrypting or releasing the DEK, managing the intermediate wrapping keys under its control,
       and performing a key sanitization.<h:br/><h:br/>
       
       The EE may provide key archiving and recovery functionality. The EE may manage the
       archiving and recovery itself, or interface with the AA to perform this function. It may also
       offer configurable features, which restricts the movement of keying material and disables
       recovery functionality.<h:br/><h:br/>
       
       The foremost security objective of encrypting storage devices is to force an adversary to
       perform an exhaustive search against a prohibitively large key space in order to recover the
       DEK or other intermediate keys. The EE uses approved cryptography to generate, handle, and
       protect keys to force an adversary who obtains an unpowered lost or stolen platform without
       the authorization factors or intermediate keys to exhaust the encryption key space of
       intermediate keys or DEK to obtain the data. The EE randomly generates DEKs and – in some
       cases - intermediate keys. The EE uses DEKs in a symmetric encryption algorithm in an
       appropriate mode along with appropriate initialization vectors for that mode to encrypt storage
       units (e.g. sectors or blocks) on the storage device. The EE either encrypts the DEK with a
       KEK or an intermediate key.<h:br/><h:br/>
       
       This version of the cPP includes additional security 1 features, included advanced power saving
       requirements and firmware signing requirements.
    </section>
       
    <section title="The TOE and the Operational and Pre-Boot Environments" id="sec-the-toe-and-the-operational-and-pre-boot-environments">
      The environment in which the EE functions may differ depending on the boot stage of the
      platform in which it operates; see Figure 3. Aspects of initialization, and perhaps authorization
      may be performed in the Pre-Boot environment, while provisioning, encryption, decryption
      and management functionality are likely performed in the Operating System environment.
      Some of these aspects may occur in both environments.
      
      The Operating System environment may make a full range of services available to the
      Encryption Engine, including hardware drivers, cryptographic libraries, and perhaps other
      services external to the TOE.
      
      The Pre-Boot environment is much more constrained with limited capabilities. This
      environment turns on the minimum number of peripherals and loads only those drivers
      necessary to bring the platform from a cold start to executing a fully functional operating
      system with running applications.
      
      The EE TOE may include or leverage features and functions within the operational
      environment.
      
      <comment>Add Figure here (from published version)</comment>
    </section>
    </section>
    
    <section title="Functionality Deferred Until the Next cPP" id="sec-TOEdescription">
      <section title="TOE Boundary" id="TOEboundary">
        <comment>NIAP: Does this still need to be incorporated?</comment>
        <h:p>
        The environment in which the AA functions may differ depending on the boot stage of the platform in which it operates, see Figure 3. Depending on the solution’s architecture, aspects of provisioning, initialization, and authorization may be performed in the Pre-Boot environment, while encryption, decryption and management functionality are likely performed in the Operating System environment. In non-software solutions, encryption/decryption starts in Pre30 OS environment and continues into OS present environment.</h:p>
        <h:p>
          In the Operating System environment, the Authorization Acquisition has the full range of services available from the operating system (OS), including hardware drivers, cryptographic libraries, and perhaps other services external to the TOE.
        </h:p>
        <h:p>The Pre-Boot environment is much more constrained with limited capabilities. This environment turns on the minimum number of peripherals and loads only those drivers necessary to bring the platform from a cold start to executing a fully functional operating system with running applications.</h:p>
        <h:p>The AA TOE may include or leverage features and functions within the operational environment.</h:p>
        <figure entity="images/fde-operating-env.png" title="Operational Environment" id="toe-oe"/>
      </section>
      
    </section>  <!-- Compliant TOEs -->

	<!-- Use Cases (optional) -->
    <section title="Use Cases" id="sec-usecases">
      The use case for a product conforming to the FDE cPPs is to protect data-at-rest on a device that is
      lost or stolen while powered off without any prior access by an adversary. The use case where an 
      adversary obtains a device that is in a powered state and is able to make modifications to the 
      environment or the TOE itself (e.g., evil maid attacks) is not addressed by these cPPs (i.e., FDE-AA and FDE- EE).
      <!-- 
      <usecases/>
      -->

    </section>  <!-- Use Cases -->

  </section>   <!-- Introduction  -->


  <!-- Conformance Claims Section -->
  <!-- New conformance claims section for CC:2022. -->
  <!-- If boilerplate is "yes" something that is probably incorrect is generated -->
  <section title="Conformance Claims" id="sec-cclaims" boilerplate="no">

	<!-- cc-version: cc-2022r1 or cc-31r5   -->
	<!-- cc-approach: standard or direct-rationale  -->
	<!-- display: Should this info be displayed in the Conformance -->
	<!-- Claims section? If no, you have to write a free-form section -->
	<CClaimsInfo 
		cc-version="cc-2022r1"         
		cc-approach="direct-rationale"         
		display="yes">                 

		<!-- Conformance for STs: exact, strict, or demonstrable -->
		<cc-st-conf>exact</cc-st-conf>                  

		<!-- Part 2 & 3 conformance (extended or conformant) -->
		<cc-pt2-conf>extended</cc-pt2-conf>           
		<cc-pt3-conf>conformant</cc-pt3-conf>           

		<!-- Claims conformance to these other PPs (none)-->
		<cc-pp-conf/>              		  
		
		<!-- Can be in a configuration with these PPs and Modules -->
		<cc-pp-config-with>
          <Mod-cc-ref>PP-Module for File Encryption Enterprise Management Version 1.0</Mod-cc-ref>
		</cc-pp-config-with>

		<!-- Package claims -->
		<cc-pkg-claim/>
	</CClaimsInfo>
  </section>  <!-- Conformance Claims -->
  
  <section title="Security Problem Definition" id="sec-spd">

    <sec:Threats>
        This section provides a narrative that describes how the requirements mitigate the mapped
        threats. A requirement may mitigate aspects of multiple threats. A requirement may only 
        mitigate a threat in a limited way. Some requirements are optional, either because the TSF
        fully mitigates the threat without the additional requirements being claimed or because the
        TSF relies on its Operational Environment to provide the functionality that is described by
        the optional requirements.<h:br/><h:br/>
        
        A threat consists of a threat agent, an asset and an adverse action of that threat agent on
        that asset. The threat agents are the entities that put the assets at risk if an adversary
        obtains a lost or stolen storage device. Threats drive the functional requirements for the 
        target of evaluation (TOE). For instance, one threat below is T.UNAUTHORIZED_DATA_ACCESS. 
        The threat agent is the possessor (unauthorized user) of a lost or stolen storage device.
        The asset is the data on the storage device, while the adverse action is to attempt to 
        obtain those data from the storage device. This threat drives the functional requirements
        for the storage device encryption (TOE) to authorize who can use the TOE to access the hard
        disk and encrypt/decrypt the data. Since possession of the KEK, DEK, intermediate keys, 
        authorization factors, submasks, and random numbers or any other values that contribute
        to the creation of keys or authorization factors could allow an unauthorized user to 
        defeat the encryption, this SPD considers key material equivalent to the data in importance
        and they appear among the other assets addressed below.<h:br/><h:br/>
      
        It is important to reemphasize at this point that this collaborative Protection Profile 
        does not expect the product (TOE) to defend against the possessor of the lost or stolen
        hard disk who can introduce malicious code or exploitable hardware components into the 
        Target of Evaluation (TOE) or the Operational Environment. It assumes that the user 
        physically protects the TOE and that the Operational Environment provides sufficient
        protection against logical attacks. One specific area where a conformant TOE offers 
        some protection is in providing updates to the TOE; other than this area, though, 
        this cPP mandates no other countermeasures. Similarly, these requirements do not 
        address the “lost and found” hard disk problem, where an adversary may have taken
        the hard disk, compromised the unencrypted portions of the boot device (e.g., MBR,
        boot partition), and then made it available to be recovered by the original user so
        that they would execute the compromised code.

		<threats>
		
		  <threat id="t-auth-guessing" name="T.AUTHORIZATION_GUESSING">
		    <description>
		      Threat agents may exercise host software to repeatedly guess authorization factors, such as passwords and PINs.
		      Successful guessing of the authorization factors may cause the TOE to release DEKs or otherwise put it in a state
		      in which it discloses protected data to unauthorized users. 
		    </description>
		    <addressed-by>FCS_SNI_EXT.1</addressed-by><rationale>Mitigates this threat by requiring  proper salts, which will prevent pre-computed attacks.</rationale>
		    <addressed-by>FCS_VAL_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat by requiring
		      several options for enforcing validation, such as key sanitization of the DEK or when a
		      configurable number of failed validation attempts is reached within a 24 hour period. This
		      mitigates brute force attacks against authorization factors such as passwords and PINs.</rationale>
		  </threat>
		  
		  <threat id="t-chosen-plaintext" name="T.CHOSEN_PLAINTEXT">
		    <description>
		      Threat agents may trick authorized users into storing chosen
		      plaintext on the encrypted storage device in the form of an image, document, or some other
		      file. A poor choice of encryption algorithms, encryption modes, and initialization vectors along
		      with the chosen plaintext could allow attackers to recover the effective DEK, thus providing
		      unauthorized access to the previously unknown plaintext on the storage device.
		    </description>
		    <addressed-by>FCS_SNI_EXT.1</addressed-by><rationale>Mitigates this threat by ensuring proper
		      handling of salts, nonces, and initialization vectors.</rationale>
		    <addressed-by>FCS_COP.1/SKC (selection-based)</addressed-by><rationale>Mitigates this threat by
		      ensuring the proper choice of encryption algorithm and mode.</rationale>
      </threat>
		  
		  <threat id="t-keying_material_compromise" name="T.KEYING_MATERIAL_COMPROMISE">
		    <description>
		      Possession of any of the keys, authorization factors, submasks, and random
		      numbers or any other values that contribute to the creation of keys or authorization factors
		      could allow an unauthorized user to defeat the encryption. The cPP considers possession of
		      key material of equal importance to the data itself. Threat agents may look for keying material
		      in unencrypted sectors of the storage device and on other peripherals in the operating environment
		      (OE), (e.g., BIOS configuration, SPI flash, or TPMs).
		    </description>
		    <addressed-by>FCS_CKM.1/DEK</addressed-by><rationale>Mitigates this threat by <comment>TBD</comment></rationale>
		    <addressed-by>FCS_CKM.6</addressed-by><rationale>Mitigates this threat by ensuring proper key material destruction.</rationale>
		    <addressed-by>FCS_CKM.6/Power</addressed-by><rationale>Mitigates this threat by ensuring proper key material destruction.</rationale>		    
		    <addressed-by>FCS_COP.1/Hash</addressed-by><rationale>Mitigates this threat by performing cryptographic hashing services.</rationale>		    
		    <addressed-by>FCS_KYC_EXT.2</addressed-by><rationale>Mitigates this threat by requiring chaining of keys to accept a BEV.</rationale>
		    <addressed-by>FCS_SNI_EXT.1</addressed-by><rationale>Mitigates this threat by requiring additional obfuscation to the protected key material by introducing IV's and salting.</rationale>
		    <addressed-by>FMT_SMF.1</addressed-by><rationale>Mitigates this threat by ensuring the TSF provides the functions necessary to manage important aspects of the TOE including generating</rationale>
		    <addressed-by>FPT_KYP_EXT.1</addressed-by><rationale>Mitigates this threat by requiring unwrapped key material is not stored in non-volatile memory.</rationale>        
		    <addressed-by>FPT_PWR_EXT.1</addressed-by><rationale>Mitigates this threat by requiring the TOE to meet a compliant power saving state that protects and/or destroys key materials.</rationale>
		    <addressed-by>FPT_PWR_EXT.2</addressed-by><rationale>Mitigates this threat by requiring the TOE to enter into a safe state based on each condition. </rationale>
		    <addressed-by>FCS_CKM.1/AKG (optional)</addressed-by><rationale>Mitigates this threat by requiring asymmetric key generation.</rationale>		    		    
		    <addressed-by>FCS_CKM.6/KEK (optional)</addressed-by><rationale>Mitigates this threat by ensuring proper key cryptographic erase.</rationale>
		    <addressed-by>FCS_CKM.1/SKG (selection-based)</addressed-by><rationale>Mitigates this threat by requiring symmetric cryptographic key generation.</rationale>		    
		    <addressed-by>FCS_CKM.6/GENHW (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring proper key material destruction in general hardware.</rationale>		    
		    <addressed-by>FCS_CKM.6/SW (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring proper key material destruction within the software TOE and 3rd party storage.</rationale>
		    <addressed-by>FCS_CKM.6/TOEHW (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring proper key material destruction.</rationale>
		    <addressed-by>FCS_COP.1/KeyedHash (selection-based)</addressed-by><rationale>Mitigates this threat by performing	cryptographic keyed-hash message authentication.</rationale>		    
		    <addressed-by>FCS_COP.1/KeyEnc (selection-based)</addressed-by><rationale>Mitigates this threat by performing key encryption and decryption.</rationale>
		    <addressed-by>FCS_COP.1/KeyEncap (selection-based)</addressed-by><rationale>Mitigates this threat by performing key transport.</rationale>
		    <addressed-by>FCS_COP.1/KeyWrap (selection-based)</addressed-by><rationale>Mitigates this threat by performing key wrapping.</rationale>			  
		    <addressed-by>FCS_COP.1/SKC (selection-based)</addressed-by><rationale>Mitigates this threat by performing data encryption and encryption.</rationale>
		    <addressed-by>FCS_KDF_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat by requiring a password that is not subject to a brute force attack.</rationale>
		    <addressed-by>FCS_RBG.1 (selection-based)</addressed-by><rationale>Mitigates this threat by randomizing the generated keys in order to reduce the likelihood of guessing the future keys.</rationale>
		    <addressed-by>FCS_RBG.2 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_RBG.3 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_RBG.4 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_RBG.5 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_SMC_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat
		      by obscuring the submasks via a XOR or hashing operation.</rationale>
		    <addressed-by>FCS_VAL_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat by defining methods for validation of keying material and number of validation attempts.</rationale>
		    <addressed-by>FPT_FLS.1 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that a malfunctioning DRBG function cannot be used to generate potentially insecure keys.</rationale>
		    <addressed-by>FPT_TST.1 (selection-based)</addressed-by><rationale>Mitigates this threat by verifying the cryptographic functionality through the self testing functionality.</rationale>
		  </threat>
		  
		  <threat id="t-keyspace-exhaust" name="T.KEYSPACE_EXHAUST">
		    <description>
		      Threat agents may perform a cryptographic exhaust against the key space. Poorly chosen
		      encryption algorithms and parameters allow attackers to exhaust the key space through brute force
		      and give them unauthorized access to the data.</description>
		    <addressed-by>FCS_CKM.1/DEK</addressed-by><rationale>Mitigates this threat by <comment>TBD</comment></rationale>
		    <addressed-by>FCS_KYC_EXT.2</addressed-by><rationale>Mitigates this threat by ensuring all keys accepting the BEV are of the same strength.</rationale>        
		    <addressed-by>FCS_CKM.1/AKG (optional)</addressed-by><rationale>Mitigates this threat by requiring asymmetric key generation.</rationale>
		    <addressed-by>FCS_CKM.1/SKG (selection-based)</addressed-by><rationale>Mitigates this threat by requiring symmetric cryptographic key generation.</rationale>
		    <addressed-by>FCS_RBG.1 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that keys used for trusted communications are generated using a secure DRBG. </rationale>
		    <addressed-by>FCS_RBG.2 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_RBG.3 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_RBG.4 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FCS_RBG.5 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that the TOE's DRBG is seeded with sufficient entropy to ensure the generation of strong cryptographic keys.</rationale>
		    <addressed-by>FPT_FLS.1 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring that a malfunctioning DRBG function cannot be used to generate potentially insecure keys.</rationale>      
		    <addressed-by>FPT_TST.1 (selection-based)</addressed-by><rationale>Mitigates this threat by verifying the cryptographic functionality through the self testing functionality.</rationale>		    
		  </threat>
		  
		  <threat id="t-known-plaintext" name="T.KNOWN_PLAINTEXT">
		    <description>
		      Threat agents know plaintext in regions of storage devices,
		      especially in uninitialized regions (all zeroes) as well as regions that contain well known
		      software such as operating systems. A poor choice of encryption algorithms, encryption modes,
		      and initialization vectors along with known plaintext could allow an attacker to recover the
		      effective DEK, thus providing unauthorized access to the previously unknown plaintext on the
		      storage device.
		    </description>		    
		    <addressed-by>FCS_SNI_EXT.1</addressed-by><rationale>Mitigates this threat by ensuring proper handling of salts, nonces, and initialization vectors.</rationale>
		    <addressed-by>FCS_COP.1/SKC (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring the proper choice of encryption algorithm and mode.</rationale>
		  </threat>
		  
		  <threat id="t-unauth-data-access" name="T.UNAUTHORIZED_DATA_ACCESS">
				<description>
				  The cPP addresses the primary threat of unauthorized disclosure of protected data stored on a 
				  storage device. If an adversary obtains a lost or stolen storage device (e.g., a storage device
				  contained in a laptop or a portable external storage device), they may attempt to connect a 
				  targeted storage device to a host of which they have complete control and have raw access to
				  the storage device (e.g., to specified disk sectors, to specified blocks).
				</description>				
		    <addressed-by>FCS_SNI_EXT.1</addressed-by><rationale>Mitigates this threat by ensuring proper nonces and IVs are used in the encryption of data.</rationale>
		    <addressed-by>FDP_DSK_EXT.1</addressed-by><rationale>Mitigates this threat by ensuring the TOE performs full drive encryption, which includes all protected data.</rationale>
		    <addressed-by>FMT_SMF.1</addressed-by><rationale>Mitigates this threat by ensuring the TSF provides the functions necessary to manage important aspects of the TOE including requests to change and erase the DEK.</rationale>        
			  <addressed-by>FPT_PWR_EXT.1</addressed-by><rationale>Mitigates this threat by defining what power states are compliant for the TOE.</rationale>
			  <addressed-by>FPT_PWR_EXT.2</addressed-by><rationale>Mitigates this threat by defining conditions in which the TOE will enter a compliant power state. These requirements ensure the device is secure if lost in a compliant power state.</rationale>        
		    <addressed-by>FCS_COP.1/SKC (selection-based)</addressed-by><rationale>Mitigates this threat by defining proper AES encryption.</rationale>
		    <addressed-by>FCS_VAL_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat by verifying the correct authentication and limits attempts to decrypt the data.</rationale>
		    <addressed-by>FPT_TST.1 (selection-based)</addressed-by><rationale>Mitigates by testing the behavior of the cryptographic functions through the use of the self-tests.</rationale>			            
      </threat>

		  <threat id="t-unauth-firmware-modify" name="T.UNAUTHORIZED_FIRMWARE_MODIFY">
		    <description>
		      An attacker attempts to modify the firmware in the SED via a command from the AA or from the
		      host platform that may compromise the security features of the TOE.
		    </description>				
		    <addressed-by>FPT_TUD_EXT.1</addressed-by><rationale>Mitigates this threat by <comment>TBD</comment></rationale>        
		    <addressed-by>FPT_FUA_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat by ensuring existing firmware cannot be modified unless replaced with a valid update initiated as part of FPT_TUD_EXT.1</rationale>
		    </threat>
		  
		  <threat id="t-unauth-firmware-update" name="T.UNAUTHORIZED_FIRMWARE_UPDATE">
		    <description>
		      An attacker attempts to replace the firmware
		      on the SED via a command from the AA or from the host platform with a malicious firmware
		      update that may compromise the security features of the TOE.
		    </description>				
		    <addressed-by>FCS_COP.1/Hash</addressed-by><rationale>Mitigates this threat by defining the cryptographic functions that can be used to validate the authenticity and integrity of firmware updates as defined by FPT_FUA_EXT.1.</rationale>
		    <addressed-by>FCS_COP.1/SigVer</addressed-by><rationale>Mitigates this threat by defining the cryptographic functions that can be used to validate the authenticity and integrity of firmware updates as defined by FPT_FUA_EXT.1.</rationale>
		    <addressed-by>FMT_SMF.1</addressed-by><rationale>Mitigates this threat by ensuring the TSF provides the functions necessary to manage important aspects of the TOE including requests to change and erase the DEK.</rationale>        
		    <addressed-by>FPT_TUD_EXT.1</addressed-by><rationale>Mitigates this threat by defining a secure mechanism for updating the TOE firmware.</rationale>
		    <addressed-by>FPT_FAC_EXT.1 (optional)</addressed-by><rationale>Mitigates this threat by providing additional security by only allowing an update to be initiated if the initiator can provide information that would only be known to a trusted administrator.</rationale>
		    <addressed-by>FPT_RBP_EXT.1 (optional)</addressed-by><rationale>Mitigates this threat by protecting against a malicious or inadvertent downgrade of the firmware to an earlier version that may have security flaws not present in the more recent version.</rationale>
		    <addressed-by>FPT_FUA_EXT.1 (selection-based)</addressed-by><rationale>Mitigates this threat by <comment>TBD</comment></rationale>		               
		  </threat>

		  <threat id="t-unauth_update" name="T.UNAUTHORIZED_UPDATE">
				<description>
				  Threat agents may attempt to perform an update of the product which compromises the security 
				  features of the TOE. Poorly chosen update protocols, signature generation and verification 
				  algorithms, and parameters may allow attackers to install software that bypasses the intended
				  security features and provides them unauthorized access to data.
				</description>        
		    <addressed-by>FCS_COP.1/SigVer</addressed-by><rationale>Mitigates this threat by defining the signature function that is used to verify updates.</rationale>        
		    <addressed-by>FMT_SMF.1</addressed-by><rationale>Mitigates this threat by ensuring the TSF provides the functions necessary to manage important behavior of the TOE which includes the initiation of system firmware/software updates.</rationale>
        <addressed-by>FPT_TUD_EXT.1</addressed-by><rationale>Mitigates this threat by providing authorized users the ability to query the current version of the TOE software/firmware, initiate updates, and verify updates prior to installation using a manufacturer digital signature.</rationale>       
		  </threat>
		</threats>
    </sec:Threats>
	
	<!-- Assumptions refer to operational objective objectives regardless of whether -->
	<!-- the document uses standard or direct rationale. -->
	
    <section title="Assumptions" id="sec-assumptions">
      <assumptions>
        <assumption name="A.INITIAL_DRIVE_STATE">
          <description>
            Users enable Full Drive Encryption on a newly provisioned storage device free of protected data in
            areas not targeted for encryption. It is also assumed that data intended for protection should not
            be on the targeted storage media until after provisioning. The cPP does not intend to include 
            requirements to find all the areas on storage devices that potentially contain protected data.
            In some cases, it may not be possible - for example, data contained in “bad” sectors. While 
            inadvertent exposure to data contained in bad sectors or un-partitioned space is unlikely, 
            one may use forensics tools to recover data from such areas of the storage device. Consequently,
            the cPP assumes bad sectors, un-partitioned space, and areas that must contain unencrypted code 
            (e.g., MBR and AA/EE pre-authentication software) contain no protected data.
          </description>
          <objective-refer ref="OE.INITIAL_DRIVE_STATE">            
              <rationale>The operational environment objective OE.INITIAL_DRIVE_STATE is realized through A.INITIAL_DRIVE_STATE.</rationale>
            </objective-refer>
        </assumption>
        
    <assumption name="A.PHYSICAL">
    <description>
      The platform is assumed to be physically protected in its Operational Environment and not subject 
      to physical attacks that compromise the security or interfere with the platform’s correct operation.
    </description>
    <objective-refer ref="OE.PHYSICAL">
      <rationale>The operational environment objective OE.PHYSICAL is realized through A.PHYSICAL.</rationale>
    </objective-refer>      
  </assumption>
        
        <assumption name="A.PLATFORM_STATE">
          <description>
            The platform in which the storage device resides (or an external storage device is connected)
            is free of malware that could interfere with the correct operation of the product.
          </description>
          <objective-refer ref="OE.PLATFORM_STATE">
            <rationale>The operational environment objective OE.PLATFORM_STATE is realized through A.PLATFORM_STATE.</rationale>
          </objective-refer>
        </assumption>
        
      <assumption name="A.POWER_DOWN">
      <description>
        The user does not leave the platform or storage device unattended
        until the device is in a compliant power saving state or has fully powered off. This properly
        clears memories and locks down the device. Authorized users do not leave the platform or
        storage device in a mode where sensitive information persists in non-volatile storage (e.g., lock
        screen or sleep state). Users power the platform or storage device down or place it into a
        power managed state, such as a “hibernation mode”.
      </description>
      <objective-refer ref="OE.POWER_DOWN">
        <rationale>The operational environment objective OE.POWER_DOWN is realized through A.POWER_DOWN.</rationale>
      </objective-refer>
    </assumption>
        
  <assumption name="A.STRONG_CRYPTO">
    <description>
      All cryptography implemented in the Operational Environment and used by the product
      meets the requirements listed in the cPP. This includes generation of external token authorization
      factors by an RBG.
    </description>
    <objective-refer ref="OE.STRONG_ENVIRONMENT_CRYPTO">
      <rationale>The operational environment objective OE.STRONG_ENVIRONMENT_CRYPTO is realized through A.STRONG_CRYPTO.</rationale>
    </objective-refer>
  </assumption>
    
        <assumption name="A.TRAINED_USER">
          <description>
            Users follow the provided guidance for securing the TOE and
            authorization factors. This includes conformance with authorization factor strength, using
            external token authentication factors for no other purpose and ensuring external token
            authorization factors are securely stored separately from the storage device or platform.
            The user should also be trained on how to power off their system.
          </description>
            <objective-refer ref="OE.PASSPHRASE_STRENGTH">
              <rationale>The operational environment objective OE.PASSPHRASE_STRENGTH is realized through A.TRAINED_USER.</rationale>
            </objective-refer>
            <objective-refer ref="OE.POWER_DOWN">
              <rationale>The operational environment objective OE.POWER_DOWN is realized through A.TRAINED_USER.</rationale>
            </objective-refer>
            <objective-refer ref="OE.SINGLE_USE_ET">
              <rationale>The operational environment objective OE.SINGLE_USE_ET is realized through A.TRAINED_USER.</rationale>
            </objective-refer>
            <objective-refer ref="OE.TRAINED_USERS">
              <rationale>The operational environment objective OE.TRAINED_USERS is realized through A.TRAINED_USER.</rationale>
            </objective-refer>
        </assumption>
        <assumption name="A.TRUSTED_CHANNEL">
          <description>
            Communication among and between product components (e.g., AA and EE) is
            sufficiently protected to prevent information disclosure. In cases in which a single
            product fulfils both cPPs, then the communication between the components does not 
            extend beyond the boundary of the TOE (e.g., communication path is within the TOE
            boundary). In cases in which independent products satisfy the requirements of the
            AA and EE, the physically close proximity of the two products during their operation
            means that the threat agent has very little opportunity to interpose itself in the 
            channel between the two without the user noticing and taking appropriate actions.
          </description>
          <objective-refer ref="OE.TRUSTED_CHANNEL">
            <rationale>The operational environment objective OE.TRUSTED_CHANNEL is realized through A.TRUSTED_CHANNEL.</rationale>
          </objective-refer>
        </assumption>
      </assumptions>
    </section>   <!-- Assumptions -->
	
	<!-- OSPs refer to Objectives or OE Objectives in standard approach documents. -->
	<!-- In direct rationale PPs, they should refer to OE Objectives -->
    <section title="Organizational Security Policies" id="sec-OSPs">
     
		<!-- 
        <OSP name="P.ENTERPRISE">
          <description>If the OS is bound to a directory or management server, the configuration of
            the OS software must be capable of adhering to the enterprise security policies
            distributed by them.</description>
        </OSP>
		-->
		
      <OSPs/>
    </section>   <!-- OSPs -->
	
	<!-- If there are no OSPs, then this: -->
<!--	<section title="Organizational Security Policies" id="sec-osp" boilerplate="no">
        <OSPs/>
    </section> 
-->
	
  </section>  <!-- Security Problem Definition -->
  
  
  <!-- This section is mandatory for standard approach documents.   -->
  <!-- It should be included in direct rationale documents if there are OE Objectives. -->
  <sec:Security_Objectives>
	 
	  
  <!--   4.1 Security Objectives for the Operational Environment -->
  <section title="Security Objectives for the Operational Environment"
	  id="SecurityObjectivesTOEorEnvironment">
	  The Operational Environment of the TOE implements technical and procedural measures to assist
	  the TOE in correctly providing its security functionality. This part wise solution forms the 
	  security objectives for the Operational Environment and consists of a set of statements describing
	  the goals that the Operational Environment should achieve.
	  <SOEs>
		<SOE name="OE.INITIAL_DRIVE_STATE">
			  <description>
			    The OE provides a newly provisioned or initialized storage device free of protected data in 
			    areas not targeted for encryption.<h:br/><h:br/>
          Rationale: Since the cPP requires all protected data to encrypted, A.INITIAL_DRIVE_STATE assumes
          that the initial state of the device targeted for FDE is free of protected data in those areas of
          the drive where encryption will not be invoked (e.g., MBR and AA and EE pre-authentication software).
          Given this known start state, the product (once installed and operational) ensures partitions of 
          logical blocks of user accessible data is protected.
         </description>
		  </SOE>
	    
		 <SOE name="OE.PASSPHRASE_STRENGTH">
			  <description>
			    An authorized administrator will be responsible for ensuring that the passphrase authorization factor 
			    conforms to guidance from the Enterprise using the TOE.<h:br/><h:br/>
			    Rationale: Users are properly trained [A.TRAINED_USER] to create authorization factors that conform to
			    administrative guidance.
        </description>
		  </SOE>
	    
	    <SOE name="OE.PHYSICAL">
			  <description>
			    The Operational Environment will provide a secure physical computing space such than an adversary
			    is not able to make modifications to the environment or to the TOE itself.<h:br/><h:br/>
			    Rationale: As stated in section 1.6, the use case for this cPP is to protect data-at-rest on a 
			    device where the adversary receives it in a powered off state and has no prior access.
			  </description>
		  </SOE>
	    
	    <SOE name="OE.PLATFORM_STATE">
			  <description>
			    The platform in which the storage device resides (or an external storage device is connected) is
			    free of malware that could interfere with the correct operation of the product.<h:br/><h:br/>
			    Rationale: A platform free of malware [A.PLATFORM_STATE] prevents an attack vector that could 
			    potentially interfere with the correct operation of the product.
			  </description>
		  </SOE>
	    
	    <SOE name="OE.POWER_DOWN">
			  <description>
			    Volatile memory is cleared after entering a compliant power-saving state or turned off so
			    memory remnant attacks are infeasible.<h:br/><h:br/>
			    Rationale: Users are properly trained [A.TRAINED_USER] to not leave the storage device unattended
			    until it is in a compliant power-saving state or fully turned off. 
			  </description>
		  </SOE>
	    
	    <SOE name="OE.SINGLE_USE_ET">
			  <description>External tokens that contain authorization factors will be used for no other purpose than
			    to store the external token authorization factor.<h:br/><h:br/>
			    Rationale: Users are properly trained [A.TRAINED_USER] to use external token authorization factors as
			    intended and for no other purpose.
			  </description>
		  </SOE>
	    
      <SOE name="OE.STRONG_ENVIRONMENT_CRYPTO">
			  <description>
			    The Operating Environment will provide a cryptographic function capability that is commensurate with the
			    requirements and capabilities of the TOE and Appendix A.<h:br/><h:br/>
			    Rationale: All cryptography implemented in the Operational Environment and used by the product meets the
			    requirements listed in this cPP [A.STRONG_CRYPTO].
			  </description>
		  </SOE>
	    
	    <SOE name="OE.TRAINED_USERS">
			  <description>
			    Authorized users will be properly trained and follow all guidance for securing the TOE and authorization factors.<h:br/><h:br/>
			    Rationale: Users are properly trained [A.TRAINED_USER] to create authorization factors that conform to guidance,
			    not store external token authorization factors with the device, and power down the TOE when required (OE.PLATFORM_STATE)
			    The platform in which the storage device resides (or an external storage device is connected) is free of malware that 
			    could interfere with the correct operation of the product.<h:br/><h:br/>
          A platform free of malware [A.PLATFORM_STATE] prevents an attack vector that could potentially interfere with the correct 
          operation of the product.
			  </description>
		  </SOE>
	    	    
	    <SOE name="OE.TRUSTED_CHANNEL">
			  <description>
			    Communication among and between product components (i.e., AA and EE) is sufficiently protected to prevent information disclosure.<h:br/><h:br/>
			    Rationale: In situations where there is an opportunity for an adversary to interpose
			    themselves in the channel between the AA and the EE, a trusted channel should be
			    established to prevent exploitation. [A.TRUSTED_CHANNEL] assumes the existence
			    of a trusted channel between the AA and EE, except for when the boundary is within
			    and does not breach the TOE or is in such close proximity that a breach is not possible
			    without detection.
			  </description>
		  </SOE>
	  </SOEs>
  </section>
	<sec:Security_Objectives_Rationale/>
  
</sec:Security_Objectives>  
<sec:Security_Requirements>  
	  
	<!--   5.1 Security Functional Requirements -->
  <sec:SFRs title="Security Functional Requirements">
    The individual security functional requirements are specified in the sections below.
    
    <section title="Cryptographic Support (FCS)" id="fcs">
	  

        <!-- FCS_CKM_EXT.1 -->
        
        <ext-comp-def title="Cryptographic Key Destruction Types" fam-id="FCS_CKM_EXT">
          <fam-behavior>This family is intended to support the ability to specify the implementation of multiple key destruction methods.
          </fam-behavior>
        </ext-comp-def>
        <ext-comp-def title="Cryptographic Key Derivation" fam-id="FCS_KDF_EXT">
          <fam-behavior>This family specifies the means by which an intermediate key is derived from a specified set of submasks.
            </fam-behavior>
        </ext-comp-def>
        <ext-comp-def title="Key Chaining" fam-id="FCS_KYC_EXT">
          <fam-behavior>This family provides the specification to be used for using multiple layers of encryption keys to ultimately secure the protected data encrypted on the drive.</fam-behavior>
        </ext-comp-def>
        <ext-comp-def title="Submask Combining" fam-id="FCS_SMC_EXT">
          <fam-behavior>This family specifies the means by which submasks are combined, if the TOE supports more than one submask being used to derive or protect the BEV.</fam-behavior>
        </ext-comp-def>
        <ext-comp-def title="Cryptographic Operation (Salt, Nonce, and Initialization Vector Generation)" fam-id="FCS_SNI_EXT">
          <fam-behavior>This family ensures that salts, nonces, and IVs are well formed.</fam-behavior>
        </ext-comp-def>
        <ext-comp-def title="Validation of Cryptographic Elements" fam-id="FCS_VAL_EXT">
          <fam-behavior>This family specifies the means by which submasks and/or BEVs are determined to be valid prior to their use.
            </fam-behavior>
        </ext-comp-def>
       
            <f-component cc-id="fcs_ckm.1" iteration="AKG" name="Cryptographic Key Generation (Asymmetric Keys)" id="fcs-ckm-1-akg" status="optional">                            
              <f-element id="fcs_ckm-1-1-akg">
                <title>
                  <comment>Reminder - Update all crypto SFRs with the crypto catalog versions when available.</comment>
                The TSF shall generate <h:b>asymmetric</h:b> cryptographic keys in accordance with a specified cryptographic key generation algorithm: <h:b><selectables linebreak='yes'>
                  <selectable>RSA schemes using cryptographic key sizes of <selectables>
                    <selectable>2048-bit</selectable>
                    <selectable>3072-bit</selectable>
                    <selectable>4096-bit</selectable>
                  </selectables> that meet the following: FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Appendix B.3</selectable>
                  <selectable>ECC schemes using “NIST curves” of <selectables>
                    <selectable>P-256</selectable>
                    <selectable>P-384</selectable>
                    <selectable>P-521</selectable>
                  </selectables> that meet the following: FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Appendix  B.4</selectable>
                  <selectable>FFC schemes using cryptographic key sizes of 
                    <selectables>
                      <selectable>2048-bit</selectable>
                      <selectable>3072-bit</selectable>
                      <selectable>4096-bit</selectable>
                    </selectables> that meet the following: FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Appendix B.1</selectable>
                  </selectables></h:b> 
                  <h:s>and specified cryptographic key sizes 
                    <assignable>cryptographic key sizes</assignable> 
                    that meet the following: 
                    <assignable>list of standards</assignable>.</h:s>
                </title>
                <note role="application">
                  Asymmetric keys may be used to “wrap” a key or submask. This SFR should be included by the ST author when making the appropriate selection in FCS_COP.                                    
                </note>
                <aactivity>
                    <TSS>The evaluator shall ensure that the TSS identifies the key sizes supported by the TOE.
                      If the ST specifies more than one scheme, the evaluator shall examine the TSS to verify
                      that it identifies the usage for each scheme.</TSS>
                    <Guidance>The evaluator shall verify that the AGD guidance instructs the administrator how to
                      configure the TOE to use the selected key generation schemes and key sizes for all
                      uses specified by the AGD documentation and defined in this cPP.</Guidance>
                    <CustomEA name="KMD">If the TOE uses an asymmetric key as part of the key chain, the KMD should detail
                      how the asymmetric key is used as part of the key chain.</CustomEA>
                    <Tests> <h:p>The following tests require the developer to provide access to a test platform that
                      provides the evaluator with tools that are typically not found on factory products.</h:p>
                      <h:p><h:b><h:i>Key Generation for FIPS PUB 186-4 RSA Schemes</h:i></h:b></h:p>
                      <h:p>The evaluator shall verify the implementation of RSA Key Generation by the TOE
                        using the Key Generation test. This test verifies the ability of the TSF to correctly
                        produce values for the key components including the public verification exponent e,
                        the private prime factors p and q, the public modulus n and the calculation of the private
                        signature exponent d.</h:p>
                        <h:p>Key Pair generation specifies 5 ways (or methods) to generate the primes p and q. These
                          include:</h:p>
                        <h:p>
                          <h:ol type='1'>
                            <h:li>Random Primes:<h:ul>
                              <h:li>Provable primes</h:li>
                              <h:li>Probable primes </h:li>
                            </h:ul></h:li>
                            <h:li>Primes with Conditions:<h:ul>
                              <h:li>Primes p1, p2, q1,q2, p and q shall all be provable primes</h:li>
                              <h:li>Primes p1, p2, q1, and q2 shall be provable primes and p and q shall be probable primes</h:li>
                              <h:li>Primes p1, p2, q1,q2, p and q shall all be probable primes</h:li>
                            </h:ul></h:li>                         
                          </h:ol></h:p>
                          <h:p>To test the key generation method for the Random Provable primes method and for all
                            the Primes with Conditions methods, the evaluator must seed the TSF key generation
                            routine with sufficient data to deterministically generate the RSA key pair. This
                            includes the random seeds, the public exponent of the RSA key, and the desired key
                            length. For each key length supported, the evaluator shall have the TSF generate 25
                            key pairs. The evaluator shall verify the correctness of the TSF’s implementation by
                            comparing values generated by the TSF with those generated from a known good
                            implementation.</h:p>
                      <h:p><h:b><h:i>Key Generation for FIPS PUB 186-4 RSA Schemes</h:i></h:b></h:p>
                            <h:p><h:i>FIPS 186-4 ECC Key Generation Test</h:i></h:p>
                            <h:p>For each supported NIST curve, i.e., P-256, P-384 and P-521, the evaluator shall
                              require the implementation under test (IUT) to generate 10 private/public key pairs.
                              The private key shall be generated using an approved random bit generator (RBG). To
                              determine correctness, the evaluator shall submit the generated key pairs to the public
                              key verification (PKV) function of a known good implementation.
                              </h:p>
                            <h:p><h:i>FIPS 186-4 Public Key Verification (PKV) Test</h:i></h:p>
                            <h:p>For each supported NIST curve, i.e., P-256, P-384 and P-521, the evaluator shall
                              generate 10 private/public key pairs using the key generation function of a known good
                              implementation and modify five of the public key values so that they are incorrect,
                              leaving five values unchanged (i.e., correct). The evaluator shall obtain in response a
                              set of 10 PASS/FAIL values.</h:p>
                            <h:p><h:b><h:i>Key Generation for Finite-Field Cryptography (FFC)</h:i></h:b></h:p>
                            <h:p>The evaluator shall verify the implementation of the Parameters Generation and the
                              Key Generation for FFC by the TOE using the Parameter Generation and Key
                              Generation test. This test verifies the ability of the TSF to correctly produce values for
                              the field prime p, the cryptographic prime q (dividing p-1), the cryptographic group
                              generator g, and the calculation of the private key x and public key y.</h:p>
                              <h:p>The Parameter generation specifies 2 ways (or methods) to generate the cryptographic
                                prime q and the field prime p:</h:p>
                                <h:p>Cryptographic and Field Primes:<h:ul>
                                  <h:li>Primes q and p shall both be provable primes</h:li>
                                  <h:li>Primes q and field prime p shall both be probable primes</h:li>
                                </h:ul>
                                and two ways to generate the cryptographic group generator g:</h:p>
                                <h:p>Cryptographic Group Generator:<h:ul>
                                  <h:li>Generator g constructed through a verifiable process</h:li>
                                  <h:li>Generator g constructed through an unverifiable process.</h:li>
                                </h:ul></h:p>
                                <h:p>The Key generation specifies 2 ways to generate the private key x:</h:p>
                                <h:p>Private Key:<h:ul>
                                  <h:li>len(q) bit output of RBG where 1 &lt;=x &lt;= q-1</h:li>
                                  <h:li>len(q) + 64 bit output of RBG, followed by a mod q-1 operation and +1
                                    operation where 1&lt;= x&lt;=q-1.</h:li>
                                </h:ul></h:p>
                                <h:p>The security strength of the RBG must be at least that of the security offered by the
                                  FFC parameter set.</h:p>
                                <h:p>To test the cryptographic and field prime generation method for the provable primes
                                  method and/or the group generator g for a verifiable process, the evaluator must seed
                                  the TSF parameter generation routine with sufficient data to deterministically generate
                                  the parameter set.</h:p>
                                <h:p>For each key length supported, the evaluator shall have the TSF generate 25 parameter
                                  sets and key pairs. The evaluator shall verify the correctness of the TSF’s
                                  implementation by comparing values generated by the TSF with those generated from
                                  a known good implementation. Verification must also confirm. <h:ul>
                                    <h:li>g != 0,1</h:li>
                                    <h:li>q divides p-1</h:li>
                                    <h:li>g^q mod p = 1</h:li>
                                    <h:li>g^x mod p = y</h:li>

                                  </h:ul>
                                  for each FFC parameter set and key pair </h:p>
                                <h:p></h:p>
                          </Tests>
                </aactivity>
              </f-element>
              
            </f-component>
        
            <f-component name="Cryptographic Key Generation (Data Encryption Key)" cc-id="fcs_ckm.1" iteration="DEK" id="fcs-ckm-1-dek">
              <f-element id="fcs_ckm-1-1-dek">
                <title>
                  The TSF shall generate cryptographic keys in accordance with a specified
                  cryptographic key generation <h:s>algorithm</h:s> <h:b>method</h:b> <selectables>
                    <selectable>generate a DEK using the RBG as specified in FCS_RBG.1</selectable>
                    <selectable>accept a DEK that is generated by the RBG provided by the host platform</selectable>
                    <selectable>accept a DEK that is wrapped as specified in FCS_COP.1<h:b>KeyWrap</h:b></selectable>
                  </selectables>
                  and specified cryptographic key sizes <selectables>
                    <selectable>128 bits</selectable>
                    <selectable>256 bits</selectable>
                  </selectables> <h:s>that meet the following: <assignable>list of
                    standards</assignable></h:s>.
                </title>
                <note role="application">
                  This SFR is iterated because additional iterations are defined as optional requirements in Appendix A.
                  This iteration was chosen specifically to ensure consistency between the FDE cPPs.<h:br/><h:br/>
                  The purpose of this requirement is to explain DEK generation during provisioning.<h:br/><h:br/>
                  If the TOE can be configured to obtain a DEK through more than one method, the ST author
                  chooses the applicable options within the selection. For example, the TOE may generate
                  random numbers with an approved RBG to create a DEK, as well as provide an interface to
                  accept a DEK from the environment.<h:br/><h:br/>
                  If the ST author chooses the first or third option, or both in the selection, the corresponding
                  requirement is pulled from Appendix A and included in the body of the ST.
                </note>
                <aactivity>
                  <TSS>
                    The evaluator shall verify that the TSS describes the known-answer self-tests for cryptographic functions.<h:br/><h:br/>
                    The evaluator shall verify that the TSS describes, for some set of non-cryptographic functions affecting 
                    the correct operation of the TOE and the method by which the TOE tests those functions. The evaluator 
                    shall verify that the TSS includes each of these functions, the method by which the TOE verifies the 
                    correct operation of the function. The evaluator shall verify that the TSF data are appropriate for 
                    TSF Testing. For example, more than blocks are tested for AES in CBC mode, output of AES in GCM mode 
                    is tested without truncation, or 512-bit key is used for testing HMAC-SHA-512.<h:br/><h:br/>
                    If FCS_RBG_EXT.1 is implemented by the TOE and according to NIST SP 800-90, the evaluator shall verify
                    that the TSS describes health tests that are consistent with section 11.3 of NIST SP 800-90.
                    If any FCS_COP functions are implemented by the TOE, the TSS shall describe the known-answer self-tests 
                    for those functions.<h:br/><h:br/>
                    The evaluator shall verify that the TSS describes, for some set of non-cryptographic functions 
                    affecting the correct operation of the TSF, the method by which those functions are tested. The TSS will
                    describe, for each of these functions, the method by which correct operation of the function/component is
                    verified. The evaluator shall determine that all of the identified functions/components are adequately 
                    tested on start-up.
                  </TSS>
                  <Guidance/>
                  <KMD/>
                  <Tests/>
                </aactivity>
              </f-element>
            </f-component>
      
      <f-component cc-id="fcs_ckm.1" iteration="SKG" name="Cryptographic Key Generation (Symmetric Keys)" id="fcs-ckm-1-b" status="sel-based">
              <depends on-sel="sel-fcs-afa-ext-1-1-sel-1b"/>
              <depends on-sel="sel-fcs-afa-ext-1-1-sel-6a"/>
              <depends on-sel="sel-fcs-kdf-ext-1-1-sel-1a"/>
              <depends on-sel="sel-fcs-kyc-ext-1-1-sel-1"/>
              <depends on-sel="sel-fcs-kyc-ext-1-1-sel-3"/>
              <depends on-sel="sel-fcs-sni-ext-1-1-sel-2"/>
              <depends on-sel="sel-fcs-sni-ext-1-3-sel-2"/>
              <depends on-sel="sel-fcs-val-ext-1-1-sel-2a"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-2"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3cii"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3ei"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eii"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eiii"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eiv"/>
              
              <f-element id="fcs_ckm-1-1-skg"><title>
                The TSF shall generate <h:b>symmetric</h:b> cryptographic keys <h:b>using a Random Bit Generator as specified in FCS_RBG.1</h:b> and specified cryptographic key
                sizes <selectables>
                  <selectable>128 bit</selectable>
                  <selectable>256 bit</selectable>
                </selectables> that meet the following: [<h:i>no standard</h:i>].
                </title>
                <note role="application">
                  Symmetric keys may be used to generate keys along the key chain. Any instance in where the TSF DRBG is referenced for key generation (as in FCS_AFA_EXT.1, 
                  FCS_SNI_EXT.1, and FCS_KDF_EXT.1), or where the TSF generates or re-generates key encryption or key wrapping keys as part of deriving a key or validating 
                  an authorization factor (as in FCS_KYC_EXT.1, FPT_KYP_EXT.1, and FCS_VAL_EXT.1)                  
                </note>
                <aactivity>
                  <TSS>The evaluator shall review the TSS to determine that a symmetric key is supported by
                    the product, that the TSS includes a description of the protection provided by the
                    product for this key. The evaluator shall ensure that the TSS identifies the key sizes
                    supported by the TOE.</TSS>
                    <Guidance>The evaluator shall verify that the AGD guidance instructs the administrator how to
                      configure the TOE to use the selected key sizes for all uses specified by the AGD
                      documentation and defined in this cPP.</Guidance>
                    <CustomEA name="KMD">If the TOE uses a symmetric key as part of the key chain, the KMD should detail how
                      the symmetric key is used as part of the key chain.</CustomEA>
                    <Tests>There are no test evaluation activities for this SFR.</Tests>
                </aactivity>
              </f-element>
              
            </f-component>
        
        <f-component cc-id="fcs_ckm.6" name="Cryptographic Key and Key Material Destruction (Destruction Timing/Method)" id="fcs-ckm-6">
              <f-element id="fcs-ckm-6e1">
                <!-- fcs_ckm-ext-4-1-a-->
                <title>
                  The TSF shall destroy [<h:i>all keys and key material</h:i>] when [<h:i>no longer
                    needed</h:i>].            
                </title>
                
                <note role="application">Keys, including intermediate keys and key material that are no longer needed are destroyed by
                  using an approved method, FCS_CKM_EXT.6. <h:br/><h:br/>
                  Examples of keys are intermediate keys, submasks, and BEV. There may be instances where keys or key material that are
                  contained in persistent storage are no longer needed and require destruction. Based on their implementation, vendors 
                  will explain when certain keys are no longer needed. There are multiple situations in which key material is no longer
                  necessary, for example, a wrapped key may need to be destroyed when a password is changed. However, there are 
                  instances when keys are allowed to remain in memory, for example, a device identification key. If a PIN was used for 
                  a smart card, the TSF should ensure that the PIN was properly destroyed.</note>
                  <aactivity level="element">
                      <TSS>The evaluator shall verify the TSS provides a high level description of what it means for keys and key material to be no longer needed and when then should be expected to be destroyed.</TSS>
                      <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
                      <CustomEA name="KMD">
                        <h:p>The evaluator shall verify the KMD includes a description of the areas where keys and
                          key material reside and when the keys and key material are no longer needed.</h:p>
                        <h:p>The evaluator shall verify the KMD includes a key lifecycle, that includes a description
                          where key material reside, how the key material is used, how it is determined that keys
                          and key material are no longer needed, and how the material is destroyed once it is not
                          needed and that the documentation in the KMD follows FCS_CKM.6/Power for the
                          destruction.</h:p></CustomEA>
                      <Tests>There are no test evaluation activities for this SFR.</Tests>
                  </aactivity>
              </f-element>
              <f-element id="fcs-ckm-6e2">
                <!-- fcs_ckm-4-1-d-->
                <title>
                  The TSF shall destroy cryptographic keys and keying material specified by
                  FCS_CKM.6.1 in accordance with a specified cryptographic key destruction method <selectables linebreak="yes">
                    <selectable>For volatile memory, the destruction shall be executed by a <selectables linebreak="yes">
                      <selectable>single overwrite consisting of <selectables linebreak="yes">
                        <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                        <selectable>zeroes,</selectable>
                        <selectable>ones,</selectable> 
                        <selectable>a new value of a key,</selectable>
                        <selectable><assignable>some value that does not contain any CSP</assignable></selectable>
                      </selectables>
                      </selectable>
                      <selectable>removal of power to the memory,</selectable>
                      <selectable>destruction of reference to the key directly followed by a request for garbage collection</selectable>
                      
                    </selectables></selectable>
                    <selectable>
                      For non-volatile storage that consists of the invocation of an interface provided by the underlying platform that <selectables linebreak="yes">
                        <selectable>logically addresses the storage location of the key and performs a <selectables>
                          <selectable>single</selectable>
                          <selectable><assignable>ST author defined multi-pass</assignable></selectable>
                        </selectables> overwrite consisting of <selectables linebreak="yes">
                          <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                          <selectable>zeroes,</selectable>
                          <selectable>ones,</selectable>
                          <selectable>a new value of a key,</selectable>
                          <selectable><assignable>some value that does not contain any CSP</assignable></selectable>
                        </selectables></selectable>
                        <selectable>instructs the underlying platform to destroy the abstraction that represents the key</selectable>
                      </selectables>
                    </selectable>
                  </selectables>
                  that meets the following: [<h:i>no standard</h:i>].
                </title>
                <note role="application">
                  <h:p>This SFR is FCS_CKM.6, to align with the numbering in the FDE EE cPP.</h:p>
                  <h:p>The interface referenced in the requirement could take different forms, the most likely of which is an application programming interface to an OS kernel. There may be various levels of abstraction visible. For instance, in a given implementation the application may have access to the file system details and may be able to logically address specific memory locations. In another implementation the application may simply have a handle to a resource and can only ask the platform to delete the resource. The level of detail to which the TOE has access will be reflected in the TSS section of the ST.</h:p>
                  <h:p>Several selections allow assignment of a ‘value that does not contain any CSP’. This means that the TOE uses some other specified data not drawn from an RBG meeting FCS_RBG.1 requirements, and not being any of the particular values listed as other selection options. The point of the phrase ‘does not contain any CSP’ is to ensure that the overwritten data is carefully selected, and not taken from a general ‘pool’ that might contain current or residual data that itself requires confidentiality protection.</h:p>
                  
                </note>
                <aactivity level="element">
                    <TSS>
                      <h:p>The evaluator examines the TSS to ensure it describes how the keys are managed in
                        volatile memory. This description includes details of how each identified key is
                        introduced into volatile memory (e.g. by derivation from user input, or by unwrapping
                        a wrapped key stored in non-volatile memory) and how they are overwritten.</h:p>
                      <h:p>The evaluator shall check to ensure the TSS lists each type of key that is stored in
                        non-volatile memory, and identifies how the TOE interacts with the underlying
                        platform to manage keys (e.g., store, retrieve, destroy). The description includes details
                        on the method of how the TOE interacts with the platform, including an identification
                        and description of the interfaces it uses to manage keys (e.g., file system APIs, platform
                        key store APIs). </h:p>
                      <h:p>The evaluator examines the interface description for each different media type to ensure
                        that the interface supports the selections and description in the TSS.</h:p>
                      <h:p>The evaluator shall check that the TSS identifies any configurations or circumstances
                        that may not strictly conform to the key destruction requirement. If the ST makes use
                        of the open assignment and fills in the type of pattern that is used, the evaluator
                        examines the TSS to ensure it describes how that pattern is obtained and used. The
                        evaluator shall verify that the pattern does not contain any CSPs.</h:p></TSS>
                      

                    <Guidance>
                      <h:p>There are a variety of concerns that may prevent or delay key destruction in some cases.
                        The evaluator shall check that the guidance documentation identifies configurations or
                        circumstances that may not strictly conform to the key destruction requirement, and
                        that this description is consistent with the relevant parts of the TSS and any other
                        relevant Required Supplementary Information. The evaluator shall check that the
                        guidance documentation provides guidance on situations where key destruction may
                        be delayed at the physical layer.</h:p>
                      <h:p>For example, when the TOE does not have full access to the physical memory, it is
                        possible that the storage may be implementing wear-leveling and garbage collection.
                        This may create additional copies of the key that are logically inaccessible but persist
                        physically. In this case, it is assumed the drive supports the TRIM command and
                        implements garbage collection to destroy these persistent copies when not actively
                        engaged in other tasks. </h:p>
                      <h:p>Drive vendors implement garbage collection in a variety of different ways, as such
                        there is a variable amount of time until data is truly removed from these solutions.
                        There is a risk that data may persist for a longer amount of time if it is contained in a
                        block with other data not ready for erasure. It is assumed the operating system and file
                        system of the OE support TRIM, instructing the non-volatile memory to erase copies
                        via garbage collection upon their deletion. </h:p>
                      <h:p>It is assumed that if a RAID array is being used, only set-ups that support TRIM are
                        utilized. It is assumed if the drive is connected via PCI-Express, the operating system
                        supports TRIM over that channel. It is assumed the drive is healthy and contains minimal corrupted data and will be end of life before a significant amount of damage
                        to drive health occurs, it is assumed there is a risk small amounts of potentially
                        recoverable data may remain in damaged areas of the drive.</h:p>
                      <h:p>Finally, it is assumed the keys are not stored using a method that would be inaccessible
                        to TRIM, such as being contained in a file less than 982 bytes which would be
                        completely contained in the master file table.</h:p></Guidance>
                    
                    <CustomEA name="KMD"> Refer to the TSS. KMD is combined with the TSS.</CustomEA>
                    <Tests>
                      <testlist>
                        <test> Applied to each key held as plaintext in volatile memory and subject to
                          destruction by overwrite by the TOE (whether or not the plaintext value is subsequently
                          encrypted for storage in volatile or non-volatile memory). In the case where the only
                          selection made for the destruction method key was removal of power, then this test is
                          unnecessary. The evaluator shall:<h:ol type="1">
                            <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                            <h:li>Cause the TOE to perform a normal cryptographic processing with the key
                              from Step #1.</h:li>
                            <h:li>Cause the TOE to clear the key.</h:li>
                            <h:li>Cause the TOE to stop the execution but not exit.</h:li>
                            <h:li>Cause the TOE to dump the entire memory of the TOE into a binary file.</h:li>
                            <h:li>Search the content of the binary file created in Step #5 for instances of the
                              known key value from Step #1.</h:li>
                            <h:li>Break the key value from Step #1 into three similar sized pieces and perform a
                              search using each piece.</h:li>
                          </h:ol>
                          <h:p>Steps 1-6 ensure that the complete key does not exist anywhere in volatile memory. If
                            a copy is found, then the test fails. </h:p>
                            <h:p>Step 7 ensures that partial key fragments do not remain in memory. If a fragment is
                              found, there is a minuscule chance that it is not within the context of a key (e.g., some
                              random bits that happen to match). If this is the case the test should be repeated with a
                              different key in Step #1. If a fragment is found the test fails.</h:p>
                              <h:p>The following tests apply only for the selection of “logically addresses the storage location…”, since the TOE in this instance has more
                                visibility into what is happening within the underlying platform (e.g., a logical view of
                                the media). For the selection of “instructs the underlying platform…”, the TOE has no visibility into the inner workings and
                                completely relies on the underlying platform, so there is no reason to test the TOE
                                beyond test 1.</h:p>
                              <h:p>For the selection of “logically addresses the storage location…”, the following tests are used to determine the TOE is able to request
                                the platform to overwrite the key with a TOE supplied pattern.</h:p>
                          </test>
                          <test>
                            Applied to each key held in non-volatile memory and subject to destruction by overwrite by the TOE. The evaluator shall use a tool that provides a logical view of the media (e.g., MBR file system):<h:ol type="1">
                              <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                              <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                              <h:li>Cause the TOE to clear the key.</h:li>
                              <h:li>Search the logical view that the key was stored in for instances of the known
                                key value from Step #1. If a copy is found, then the test fails.</h:li>
                              <h:li>Break the key value from Step #1 into three similar sized pieces and perform a
                                search using each piece. If a fragment is found then the test is repeated (as
                                described for Use Case 1 test 1 above), and if a fragment is found in the
                                repeated test then the test fails.</h:li>
                              

                            </h:ol>
                          </test>
                          <test>
                            Applied to each key held as non-volatile memory and subject to destruction by overwrite by the TOE. The evaluator shall use a tool that provides a logical view of the media:<h:ol type="1">
                              <h:li>Record the logical storage location of the key in the TOE subject to clearing</h:li>
                              <h:li>Cause the TOE to perform a normal cryptographic processing with the key
                                from Step #1.</h:li>
                              <h:li>Cause the TOE to clear the key.</h:li>
                              <h:li>Read the logical storage location in Step #1 of non-volatile memory to ensure
                                the appropriate pattern is utilized.</h:li>
                            </h:ol>
                            <h:p>
                              The test succeeds if correct pattern is used to overwrite the key in the memory location. If the pattern is not found the test fails.
                            </h:p>
                          </test>
                      </testlist>
                    </Tests>
                </aactivity>
              </f-element>
          
            </f-component>
      
      <f-component name="Cryptographic Key Destruction (General Hardware)" cc-id="fcs_ckm.6"
        iteration="GENHW" id="fcs-ckm-6-genhw" status="sel-based">
        <depends on-sel="fcs-ckm-ext-6"></depends>
        <f-element id="fcs_ckm-6-1-genhw">
          <title>
            The TSF shall destroy <assignable>list of cryptographic keys (including keying material)</assignable>
            when [<h:i>no longer needed</h:i>].
          </title>
          
        </f-element>
        <f-element id="fcs_ckm-6-2-genhw">
          <title>
            The TSF shall destroy cryptographic keys and keying material specified in FCS_CKM.6.1 in accordance with a specified cryptographic
            key destruction method <selectables linebreak="yes">
              <selectable>For volatile memory, the destruction shall be executed by a <selectables linebreak="yes">
                <selectable>single overwrite consisting of <selectables linebreak="yes">
                  <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                  <selectable>zeroes,</selectable>
                  <selectable>ones,</selectable> 
                  <selectable>a new value of a key,</selectable>
                  <selectable><assignable>some value that does not contain any CSP</assignable></selectable>
                </selectables>
                </selectable>
                <selectable>removal of power to the memory,</selectable>
                <selectable>destruction of reference to the key directly followed by a request for garbage collection</selectable>
                
              </selectables></selectable>
              <selectable>
                For non-volatile memory, the destruction shall be executed by a <selectables linebreak="yes">
                    <selectable>single</selectable>
                    <selectable><assignable>ST author defined multi-pass</assignable></selectable>
                  </selectables> overwrite consisting of <selectables linebreak="yes">
                    <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                    <selectable>zeroes,</selectable>
                    <selectable>ones,</selectable>
                    <selectable>a new value of a key of the same size,</selectable>
                    <selectable><assignable>some value that does not contain any CSP</assignable></selectable>
                    <selectable>block erase</selectable>
                  </selectables></selectable>                  
                </selectables>
            that meets the following: [<h:i>no standard</h:i>].
          </title>
          <note role="application">
            This SFR must be included in the ST if selected in FCS_CKM_EXT.6.<h:br/><h:br/>
            This SFR should be 
            In the first selection, the ST Author is presented options for destroying disused cryptographic
            keys based on whether they are in volatile memory or non-volatile storage within the TOE. The 
            selection of block erase for non-volatile storage applies only to flash memory. A block erase
            does not require a read-verify, since the reference to the memory location is erased as well 
            as the data itself.<h:br/><h:br/>
            Within the selections is the option to overwrite the memory location with a new value of a key.
            The intent is that a new value of a key (as specified in another SFR within the PP) can be used
            to “replace” an existing key.<h:br/><h:br/>
            Several selections allow assignment of a ‘value that does not contain any CSP’. This means
            that the TOE uses some other specified data not drawn from an RBG meeting FCS_RBG
            requirements, and not being any of the particular values listed as other selection options. The
            point of the phrase ‘does not contain any CSP’ is to ensure that the overwritten data is carefully
            selected, and not taken from a general ‘pool’ that might contain current or residual data that
            itself requires confidentiality protection.<h:br/><h:br/>
            Key destruction does not apply to the public component of asymmetric key pairs.
          </note>
          <aactivity>
            <TSS>
              (Key Management Description may be used if necessary details describe proprietary information)<h:br/><h:br/>
              The evaluator examines the TSS to ensure it describes how the keys are managed in volatile memory.
              This description includes details of how each identified key is introduced into volatile memory 
              (e.g. by derivation from user input, or by unwrapping a wrapped key stored in non-volatile memory)
              and how they are overwritten.<h:br/><h:br/>
              The evaluator shall check to ensure the TSS lists each type of key that is stored, and identifies 
              the memory type (volatile or non-volatile) where key material is stored.<h:br/><h:br/>
              The TSS identifies and describes the interfaces that is used to service commands to read/write 
              memory. The evaluator examines the interface description for each different media type to ensure
              that the interface supports the selections made by the ST Author.<h:br/><h:br/>
              If the ST makes use of the open assignment and fills in the type of pattern that is used, the 
              evaluator examines the TSS to ensure it describes how that pattern is obtained and used. The 
              evaluator shall verify that the pattern does not contain any CSPs.<h:br/><h:br/>
              The evaluator shall check that the TSS identifies any configurations or circumstances that
              may not strictly conform to the key destruction requirement.
            </TSS>
            <Guidance>
              There are a variety of concerns that may prevent or delay key destruction in some cases. The 
              evaluator shall check that the guidance documentation identifies configurations or circumstances
              that may not strictly conform to the key destruction requirement, and that this description is 
              consistent with the relevant parts of the TSS and any other relevant Required Supplementary 
              Information. The evaluator shall check that the guidance documentation provides guidance on 
              situations where key destruction may be delayed at the physical layer.<h:br/><h:br/>
              For example, when the TOE does not have full access to the physical memory, it is possible that 
              the storage may be implementing wear-leveling and garbage collection. This may create additional
              copies of the key that are logically inaccessible but persist physically. In this case, it is 
              assumed the drive supports the TRIM command and implements garbage collection to destroy these
              persistent copies when not actively engaged in other tasks.<h:br/><h:br/>
              Drive vendors implement garbage collection in a variety of different ways, as such there is a 
              variable amount of time until data is truly removed from these solutions. There is a risk that
              data may persist for a longer amount of time if it is contained in a block with other data not
              ready for erasure. It is assumed the operating system and file system of the OE support TRIM, 
              instructing the non-volatile memory to erase copies via garbage collection upon their deletion.<h:br/><h:br/>
              It is assumed that if a RAID array is being used, only set-ups that support TRIM are utilized. 
              It is assumed if the drive is connected via PCI-Express, the operating system supports TRIM over
              that channel. It is assumed the drive is healthy and contains minimal corrupted data and will be
              end of life before a significant amount of damage to drive health occurs, it is assumed there is
              a risk small amounts of potentially recoverable data may remain in damaged areas of the drive.<h:br/><h:br/>
              Finally, it is assumed the keys are not stored using a method that would be inaccessible to TRIM,
              such as being contained in a file less than 982 bytes which would be completely contained in the 
              master file table.
            </Guidance>
            <Tests>
              For these tests the evaluator shall utilize appropriate development environment (e.g. a Virtual Machine)
              and development tools (debuggers, simulators, etc.) to test that keys are cleared, including all copies 
              of the key that may have been created internally by the TOE during normal cryptographic processing with
              that key.
              <testlist>
                <test>Applied to each key held as plaintext in volatile memory and subject to destruction by overwrite
                  by the TOE (whether or not the plaintext value is subsequently encrypted for storage in volatile or 
                  non-volatile memory). In the case where the only selection made for the destruction method key was 
                  removal of power, then this test is unnecessary. The evaluator shall:<h:ol type="1">
                    <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>
                    <h:li>Cause the TOE to stop the execution but not exit.</h:li>
                    <h:li>Cause the TOE to dump the entire memory of the TOE into a binary file.</h:li>
                    <h:li>Search the content of the binary file created in Step #5 for instances of the known key value from Step #1.</h:li>
                    <h:li>Break the key value from Step #1 into three similar sized pieces and perform a search using each piece.</h:li>
                  </h:ol>
                  Steps 1-6 ensure that the complete key does not exist anywhere in volatile memory. If a copy is found,
                  then the test fails.<h:br/><h:br/>
                  Step 7 ensures that partial key fragments do not remain in memory. If a fragment is found, there is a 
                  miniscule chance that it is not within the context of a key (e.g., some random bits that happen to match).
                  If this is the case the test should be repeated with a different key in Step #1. If a fragment is found 
                  the test fails.
                </test>
                <test>
                  Applied to each key held in non-volatile memory and subject to destruction by overwrite by the TOE. The 
                  evaluator shall use special tools (as needed), provided by the TOE developer if necessary, to view the 
                  key storage location:<h:ol type="1">
                    <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>                    
                    <h:li>Search the non-volatile memory the key was stored in for instances of the known key value from 
                      Step #1. If a copy is found, then the test fails.</h:li>
                    <h:li>Break the key value from Step #1 into three similar sized pieces and perform a search using each 
                      piece. If a fragment is found then the test is repeated (as described for test 1 above), and if 
                      a fragment is found in the repeated test then the test fails.</h:li>
                  </h:ol>
                </test>
                <test>
                  Applied to each key held as non-volatile memory and subject to destruction by overwrite by the TOE. 
                  The evaluator shall use special tools (as needed), provided by the TOE developer if necessary, to 
                  view the key storage location:<h:ol type="1">
                    <h:li>Record the storage location of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>
                    <h:li>Search the storage location in Step #1 of non-volatile memory to ensure
                      the appropriate pattern is used.</h:li>
                  </h:ol>
                  The test succeeds if the correct pattern is used to overwrite the key in the
                  memory location. If the pattern is not found, the test fails. 
                </test>
              </testlist>              
            </Tests>
          </aactivity>
        </f-element>
      </f-component>
      
      <f-component name="Cryptographic Key Destruction (Key Cryptographic Erase)" cc-id="fcs_ckm.6"
        iteration="KEK" id="fcs-ckm-6-kek" status="optional">
        <f-element id="fcs-ckm-6-1-kek">
          <title>
            The TSF shall destroy <assignable>list of cryptographic keys (including keying material)</assignable>
            when [<h:i>no longer needed</h:i>].
          </title>          
        </f-element>
        
        <f-element id="fcs-ckm-6-2-kek">
          <title>
            The TSF shall destroy cryptographic keys and keying material specified by FCS_CKM.6.1 in accordance
            with a specified cryptographic key destruction method [<h:i>by using the appropriate method to destroy
            all encryption keys encrypting the key intended for destruction</h:i>] that meets the following: 
            [<h:i>no standard</h:i>].
          </title>
          <note role="application">
            A key can be considered destroyed by destroying the key that protects the
            key. If a key is wrapped or encrypted it is not necessary to “overwrite” that key, overwriting
            the key that is used to wrap or encrypt the key used to encrypt/decrypt data, using the
            appropriate method for the memory type involved, will suffice. For example, if a product uses
            a Key Encryption Key (KEK) to encrypt a Data Encryption Key (DEK), destroying the KEK
            using one of the methods in FCS_CKM.EXT.6.1 is sufficient, since the DEK would no longer
            be usable (of course, presumes the DEK is still encrypted.
          </note>
          <aactivity>
            <TSS/>
            <Guidance/>
            <KMD>
              The evaluator shall examine the TOE’s keychain in the TSS/KMD and identify each instance a
              key is destroyed by this method. In each instance the evaluator shall verify all keys capable
              of decrypting the target key are destroyed in accordance with a specified key destruction method.
            </KMD>
            <Tests/>
          </aactivity>
        </f-element>
      </f-component>            
        
            <f-component cc-id="fcs_ckm.6" iteration="Power" name="Cryptographic Key and Key Material Destruction (Power Management)" id="fcs-ckm-6-power">
              <f-element id="fcs-ckm-6e1-pwr">
                <!--fcs_ckm-4-1-a -->
                <title>                  
                  The TSF shall <h:b><selectables>
                    <selectable>instruct the operational environment to clear</selectable>
                    <selectable>erase</selectable>
                  </selectables></h:b> [<h:i>cryptographic keys and key material from volatile
                    memory</h:i>] when [<h:i>transitioning to a compliant power saving state as
                      defined by FPT_PWR_EXT.1</h:i>] that meets the following: [<h:i>a key
                        destruction method specified in FCS_CKM_EXT.6</h:i>].
                </title>
                <note role="application">
                  In some cases, erasure of keys from volatile memory is
                  only supported by the operational environment, in which case the operational
                  environment must expose a well-documented mechanism or interface to invoke the memory clearing operation.<h:br/><h:br/>
                  
                  Self-encrypting drives do not store keys in the Operational Environment and cannot instruct
                  the Operational Environment to perform functionality so they are not expected to select
                  “instruct the Operational Environment to clear”.
                </note>
                <aactivity level="element">
                  <TSS>
                    The evaluator shall verify the TSS provides a high level description of how keys stored in volatile memory are destroyed. The valuator to verify that TSS outlines: <h:ul>
                      <h:li>if and when the TSF or the Operational Environment is used to destroy keys from volatile memory;</h:li>
                      <h:li>if and how memory locations for (temporary) keys are tracked;</h:li>
                      <h:li>details of the interface used for key erasure when relying on the OE for memory clearing.</h:li></h:ul></TSS>
                  <Guidance>The evaluator shall check the guidance documentation if the TOE depends on the
                    Operational Environment for memory clearing and how that is achieved.</Guidance>
                  <CustomEA name="KMD">The evaluator shall check to ensure the KMD lists each type of key, its origin, possible memory locations in volatile memory.</CustomEA>
                  <Tests>There are no test evaluation activities for this SFR.</Tests>
                </aactivity>
              </f-element>
              <f-element id="fcs-ckm-6e2-pwr">
                <!-- fcs_ckm-ext-4-1-b-->
                <title>
                  The TSF shall destroy [<h:i>all key material, BEV, and authentication factors
                    stored in plaintext</h:i>] when [<h:i>transitioning to a compliant power saving
                      state as defined by FPT_PWR_EXT.1</h:i>].
                </title>
                <note role="application">The TOE may end up in a non-compliant power saving
                  state indistinguishable from a compliant power state (e.g. as result of sudden or
                  unexpected power loss). For those scenarios, the TOE or the operational
                  environment guidance documentation must provide procedures to support destruction of key material (e.g., automated reboot with memory clearing in early stages of the system’s power-on sequence).</note>
                  <aactivity level="element">
                    <TSS>The evaluator shall verify the TSS provides a description of what keys and key material
                      are destroyed when entering any compliant power saving state.</TSS>
                      <Guidance>The evaluator shall validate that guidance documentation contains clear warnings and
                        information on conditions in which the TOE may end up in a non-compliant power
                        saving state indistinguishable from a compliant power saving state. In that case it must
                        contain mitigation instructions on what to do in such scenarios.</Guidance>
                      <CustomEA name="KMD">
                        <h:p>The evaluator shall verify the KMD includes a description of the areas where keys and
                          key material reside.</h:p>
                          <h:p>The evaluator shall verify the KMD includes a key lifecycle that includes a description
                            where key material resides, how the key material is used, and how the material is
                            destroyed once it is not needed and that the documentation in the KMD follows
                            FCS_CKM.6 for the destruction.</h:p></CustomEA>
                      <Tests>There are no test evaluation activities for this SFR.</Tests>
                  </aactivity>
              </f-element>          
            </f-component>
      
      <f-component name="Cryptographic Key Destruction (Software TOE, 3rd Party Storage)" cc-id="fcs_ckm.6"
        iteration="SW" id="fcs-ckm-6-sw" status="sel-based">
        <depends on-sel="fcs-ckm-ext-6"/>
        <f-element id="fcs_ckm-6-1-sw">
          <title>
            The TSF shall destroy <assignable>list of cryptographic keys (including keying material)</assignable>
            when [<h:i>no longer needed</h:i>].
          </title>
          
        </f-element>
        <f-element id="fcs_ckm-6-2-sw">
          <title>
            The TSF shall destroy cryptographic keys and keying material specified in FCS_CKM.6.1 in accordance with a specified cryptographic
            key destruction method <selectables linebreak="yes">
              <selectable>For volatile memory, the destruction shall be executed by a <selectables linebreak="yes">
                <selectable>single overwrite consisting of <selectables linebreak="yes">
                  <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                  <selectable>zeroes,</selectable>
                  <selectable>ones,</selectable> 
                  <selectable>a new value of a key,</selectable>
                  <selectable><assignable>some value that does not contain any CSP</assignable></selectable>
                </selectables>
                </selectable>
                <selectable>removal of power to the memory,</selectable>
                <selectable>destruction of reference to the key directly followed by a request for garbage collection</selectable>
                </selectables></selectable>
              <selectable>
                For non-volatile storage that consists of the invocation of an interface provided
                by the underlying platform that <selectables linebreak="yes">
                  <selectable>logically addresses the storage location of the key and performs a <selectables>
                    <selectable>single</selectable>
                    <selectable><assignable>ST author defined multi-pass</assignable></selectable></selectables>
                    overwrite consisting of <selectables linebreak="yes">
                  <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                  <selectable>zeroes,</selectable>
                  <selectable>ones,</selectable>
                  <selectable>a new value of a key of the same size,</selectable>
                  <selectable><assignable>some value that does not contain any
                    CSP</assignable></selectable></selectables></selectable>
                  <selectable>instructs the underlying platform to destroy the abstraction that
                    represents the key</selectable>
                </selectables></selectable>                  
            </selectables>
            that meets the following: [<h:i>no standard</h:i>].
          </title>
          <note role="application">
            This SFR must be included in the ST if selected in FCS_CKM_EXT.6.<h:br/><h:br/>
            The interface referenced in the requirement could take different forms, the
            most likely of which is an application programming interface to an OS kernel. There may be
            various levels of abstraction visible. For instance, in a given implementation the application
            may have access to the file system details and may be able to logically address specific memory
            locations. In another implementation the application may simply have a handle to a resource
            and can only ask the platform to delete the resource. The level of detail to which the TOE has
            access will be reflected in the TSS section of the ST.<h:br/><h:br/>
            Several selections allow assignment of a ‘value that does not contain any CSP’. This means
            that the TOE uses some other specified data not drawn from an RBG meeting FCS_RBG
            requirements, and not being any of the particular values listed as other selection options. The
            point of the phrase ‘does not contain any CSP’ is to ensure that the overwritten data is carefully
            selected, and not taken from a general ‘pool’ that might contain current or residual data that
            itself requires confidentiality protection.<h:br/><h:br/>            
            Key destruction does not apply to the public component of asymmetric key pairs.
          </note>
          <aactivity>
            <TSS>
              (Key Management Description may be used if necessary details describe proprietary information)<h:br/><h:br/>
              The evaluator examines the TSS to ensure it describes how the keys are managed in volatile memory.
              This description includes details of how each identified key is introduced into volatile memory (e.g.,
              by derivation from user input, or by unwrapping a wrapped key stored in non-volatile memory) and how 
              they are overwritten.<h:br/><h:br/>
              The evaluator shall check to ensure the TSS lists each type of key that is stored in non-volatile
              memory, and identifies how the TOE interacts with the underlying platform to manage keys (e.g., store,
              retrieve, destroy). The description includes details on the method of how the TOE interacts with the 
              platform, including an identification and description of the interfaces it uses to manage keys (e.g.,
              file system APIs, platform key store APIs).<h:br/><h:br/>
              The evaluator examines the interface description for each different media type to ensure that the 
              interface supports the selections and description in the TSS.<h:br/><h:br/>
              The evaluator shall check that the TSS identifies any configurations or circumstances that may not
              strictly conform to the key destruction requirement. If the ST makes use of the open assignment and
              fills in the type of pattern that is used, the evaluator examines the TSS to ensure it describes how
              that pattern is obtained and used. The evaluator shall verify that the pattern does not contain any
              CSPs.              
            </TSS>
            <Guidance>
              There are a variety of concerns that may prevent or delay key destruction in some cases. The evaluator
              shall check that the guidance documentation identifies configurations or circumstances that may not 
              strictly conform to the key destruction requirement, and that this description is consistent with the
              relevant parts of the TSS and any other relevant Required Supplementary Information. The evaluator 
              shall check that the guidance documentation provides guidance on situations where key destruction may
              be delayed at the physical layer.<h:br/><h:br/>
              For example, when the TOE does not have full access to the physical memory, it is possible that the 
              storage may be implementing wear-leveling and garbage collection. This may create additional copies
              of the key that are logically inaccessible but persist physically. In this case, it is assumed the 
              drive supports the TRIM command and implements garbage collection to destroy these persistent copies
              when not actively engaged in other tasks.<h:br/><h:br/>
              Drive vendors implement garbage collection in a variety of different ways, as such there is a variable
              amount of time until data is truly removed from these solutions. There is a risk that data may persist
              for a longer amount of time if it is contained in a block with other data not ready for erasure. It is
              assumed the operating system and file system of the OE support TRIM, instructing the non-volatile memory
              to erase copies via garbage collection upon their deletion.<h:br/><h:br/>
              It is assumed that if a RAID array is being used, only set-ups that support TRIM are utilized. It is 
              assumed if the drive is connected via PCI-Express, the operating system supports TRIM over that channel.
              It is assumed the drive is healthy and contains minimal corrupted data and will be end of life before a 
              significant amount of damage to drive health occurs, it is assumed there is a risk small amounts of 
              potentially recoverable data may remain in damaged areas of the drive.<h:br/><h:br/>
              Finally, it is assumed the keys are not stored using a method that would be inaccessible to TRIM, such 
              as being contained in a file less than 982 bytes which would be completely contained in the master 
              file table.
            </Guidance>
            <Tests>
              <testlist>
                <test>Applied to each key held as plaintext in volatile memory and subject to destruction by overwrite
                  by the TOE (whether or not the plaintext value is subsequently encrypted for storage in volatile or 
                  non-volatile memory). In the case where the only selection made for the destruction method key was 
                  removal of power, then this test is unnecessary. The evaluator shall:<h:ol type="1">
                    <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>
                    <h:li>Cause the TOE to stop the execution but not exit.</h:li>
                    <h:li>Cause the TOE to dump the entire memory of the TOE into a binary file.</h:li>
                    <h:li>Search the content of the binary file created in Step #5 for instances of the known key value from Step #1.</h:li>
                    <h:li>Break the key value from Step #1 into three similar sized pieces and perform a search using each piece.</h:li>
                  </h:ol>
                  Steps 1-6 ensure that the complete key does not exist anywhere in volatile memory. If a copy is found,
                  then the test fails.<h:br/><h:br/>
                  Step 7 ensures that partial key fragments do not remain in memory. If a fragment is found, there is a 
                  miniscule chance that it is not within the context of a key (e.g., some random bits that happen to match).
                  If this is the case the test should be repeated with a different key in Step #1. If a fragment is found 
                  the test fails.
                </test>
                The following tests apply only to selection a), since the TOE in this instance has more visibility into what is 
                happening within the underlying platform (e.g., a logical view of the media). In selection b), the TOE has no 
                visibility into the inner workings and completely relies on the underlying platform, so there is no reason to
                test the TOE beyond test 1.<h:br/><h:br/>
                For selection a), the following tests are used to determine the TOE is able to request the platform to overwrite
                the key with a TOE supplied pattern.
                <test>
                  Applied to each key held in non-volatile memory and subject to destruction by overwrite by the TOE. The 
                  evaluator shall use a tool that provides a logical view of the media (e.g., MBR
                  file system):<h:ol type="1">
                    <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>                    
                    <h:li>Search the logical view that the key was stored in for instances of the known key value from 
                      Step #1. If a copy is found, then the test fails.</h:li>
                    <h:li>Break the key value from Step #1 into three similar sized pieces and perform a search using each 
                      piece. If a fragment is found then the test is repeated (as described for Use
                      Case 1 test 1 above), and if a fragment is found in the repeated test then the test fails.</h:li>
                  </h:ol>
                </test>
                <test>
                  Applied to each key held as non-volatile memory and subject to destruction by overwrite by the TOE. 
                  The evaluator shall use a tool that provides a logical view of the media:<h:ol type="1">
                    <h:li>Record the logical storage location of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>
                    <h:li>Read the logical storage location in Step #1 of non-volatile memory to
                      ensure the appropriate pattern is used.</h:li>
                  </h:ol>
                  The test succeeds if the correct pattern is used to overwrite the key in the
                  memory location. If the pattern is not found, the test fails. 
                </test>
              </testlist>              
            </Tests>
          </aactivity>
        </f-element>
      </f-component>
      
      <f-component name="Cryptographic Key Destruction (TOE-Controlled Hardware)" cc-id="fcs_ckm.6"
        iteration="TOEHW" id="fcs-ckm-6-toehw" status="sel-based">
        <depends on-sel="fcs-ckm-ext-6"/>
        <f-element id="fcs_ckm-6-1-toehw">
          <title>
            The TSF shall destroy <assignable>list of cryptographic keys (including keying material)</assignable>
            when [<h:i>no longer needed</h:i>].
          </title>
          
        </f-element>
        <f-element id="fcs_ckm-6-2-toehw">
          <title>
            The TSF shall destroy cryptographic keys and keying material specified in FCS_CKM.6.1 in accordance with a specified cryptographic
            key destruction method <selectables linebreak="yes">
              <selectable>For volatile memory, the destruction shall be executed by a <selectables linebreak="yes">
                <selectable>single overwrite consisting of <selectables linebreak="yes">
                  <selectable>a pseudo-random pattern using the TSF’s RBG,</selectable>
                  <selectable>zeroes,</selectable>
                  <selectable>ones,</selectable> 
                  <selectable>a new value of a key,</selectable>
                  <selectable><assignable>some value that does not contain any CSP</assignable></selectable>
                </selectables>
                </selectable>
                <selectable>removal of power to the memory,</selectable>
                <selectable>destruction of reference to the key directly followed by a request for garbage collection</selectable>
              </selectables></selectable>
              <selectable>
                For non-volatile <selectables linebreak="yes">
                  <selectable>that employs a wear-leveling algorithm, the destruction shall be
                    executed by a <selectables>
                    <selectable>single overwrite consisting of zeroes</selectable>
                    <selectable>single overwrite consisting of ones</selectable>
                    <selectable>overwrite with a new value of a key of the same size</selectable>
                    <selectable>single overwrite consisting of <assignable>some value that does not
                      29 contain any CSP</assignable></selectable>
                      <selectable>block erase</selectable>
                    </selectables></selectable>
                    <selectable>that does not employ a wear-leveling algorithm, the destruction
                      shall be executed by a <selectables linebreak="yes">
                      <selectable><selectables>
                        <selectable>single</selectable>
                        <selectable><assignable>ST author defined multi-pass</assignable> overwrite consisting of zeros followed by a read-verify</selectable>
                        </selectables></selectable>
                      <selectable><selectables>
                          <selectable>single</selectable>
                          <selectable><assignable>ST author defined multi-pass</assignable> overwrite
                            consisting of ones followed by a read-verify</selectable>
                          </selectables></selectable>
                      <selectable><selectables>
                          <selectable>single</selectable>
                          <selectable><assignable>ST author defined multi-pass</assignable>overwrite
                            consisting of <assignable>some value that does not contain any CSP</assignable> followed by a read-verify</selectable>
                          </selectables>block erase</selectable>
                      </selectables></selectable>                  
                </selectables>and if the read-verification of the overwritten data fails, the process shall
                  be repeated again up to [assignment: number of times to attempt
                  overwrite] times, whereupon an error is returned.</selectable>                  
            </selectables>
            that meets the following: [<h:i>no standard</h:i>].
          </title>
          <note role="application">
            This SFR must be included in the ST if selected in FCS_CKM_EXT.6.<h:br/><h:br/>
            In the first selection, the ST Author is presented options for destroying a
            key based on the memory or storage technology where keys are stored within the TOE.<h:br/><h:br/>
            If non-volatile memory is used to store keys, the ST Author selects whether the memory
            storage algorithm uses wear-leveling or not. Storage technologies or memory types that use
            wear-leveling are not required to perform a read verify. The selection for destruction
            includes block erase as an option, and this option applies only to flash memory. A block erase
            does not require a read verify, since the mappings of logical addresses to the erased memory
            locations are erased as well as the data itself.<h:br/><h:br/>    
            Within the selections is the option to overwrite a disused key with a new value of a key. The
            intent is that a new value of a key (as specified in another SFR within the PP) can be used to
            “replace” an existing key.<h:br/><h:br/>
            If a selection for read verify is chosen, it should generate an audit record upon failures.<h:br/><h:br/>
            Several selections allow assignment of a ‘value that does not contain any CSP’. This means
            that the TOE uses some other specified data not drawn from an RBG meeting
            FCS_RBG_EXT requirements, and not being any of the particular values listed as other
            selection options. The point of the phrase ‘does not contain any CSP’ is to ensure that the
            overwritten data is carefully selected, and not taken from a general ‘pool’ that might contain
            current or residual data that itself requires confidentiality protection.<h:br/><h:br/>
            Key destruction does not apply to the public component of asymmetric key pairs.
          </note>
          <aactivity>
            <TSS>
              (Key Management Description may be used if necessary details describe proprietary information)<h:br/><h:br/>
              The evaluator examines the TSS to ensure it describes how the keys are managed in volatile memory.
              This description includes details of how each identified key is introduced into volatile memory (e.g.,
              by derivation from user input, or by unwrapping a wrapped key stored in non-volatile memory) and how 
              they are overwritten.<h:br/><h:br/>
              The evaluator shall examine the TSS to ensure it describes the method that is used by the memory 
              controller to write and read memory from each type of memory listed. The purpose here is to provide
              a description of how the memory controller works so one can determine exactly how keys are written 
              to memory. The description would include how the data is written to and read from memory (e.g., block
              level, cell level), mechanisms for copies of the key that could potentially exist (e.g., a copy with 
              parity bits, a copy without parity bits, any mechanisms that are used for redundancy).<h:br/><h:br/>
              The evaluator shall examine the TSS to ensure it describes the destruction procedure for each key that
              has been identified. If different types of memory are used to store the keys, the evaluator shall 
              check to ensure that the TSS identifies the destruction procedure for each memory type where keys are
              stored (e.g., key X stored in flash memory is destroyed by overwriting once with zeros, key X’ stored
              in EEPROM is destroyed by a overwrite consisting of a pseudo random pattern – the EEPROM used in the 
              TOE uses a wear-leveling scheme as described).<h:br/><h:br/>
              If the ST makes use of the open assignment and fills in the type of pattern that is used, the evaluator
              examines the TSS to ensure it describes how that pattern is obtained and used. The evaluator shall verify
              that the pattern does not contain any CSPs.<h:br/><h:br/>
              The evaluator shall check that the TSS identifies any configurations or circumstances that may not strictly
              conform to the key destruction requirement.<h:br/><h:br/>
              Upon completion of the TSS examination, the evaluator understands how all the keys
              (and potential copies) are destroyed.
                            
            </TSS>
            <Guidance>
              There are a variety of concerns that may prevent or delay key destruction in some cases. The evaluator
              shall check that the guidance documentation identifies configurations or circumstances that may not 
              strictly conform to the key destruction requirement, and that this description is consistent with 
              the relevant parts of the TSS and any other relevant Required Supplementary Information. The evaluator 
              shall check that the guidance documentation provides guidance on situations where key destruction may 
              be delayed at the physical layer.<h:br/><h:br/>
              For example, when the TOE does not have full access to the physical memory, it is possible that the 
              storage may be implementing wear-leveling and garbage collection. This may create additional copies
              of the key that are logically inaccessible but persist physically. In this case, it is assumed the 
              drive supports the TRIM command and implements garbage collection to destroy these persistent copies
              when not actively engaged in other tasks.<h:br/><h:br/>
              Drive vendors implement garbage collection in a variety of different ways, as such there is a variable
              amount of time until data is truly removed from these solutions. There is a risk that data may persist
              for a longer amount of time if it is contained in a block with other data not ready for erasure. It is
              assumed the operating system and file system of the OE support TRIM, instructing the non-volatile memory
              to erase copies via garbage collection upon their deletion.<h:br/><h:br/>
              It is assumed that if a RAID array is being used, only set-ups that support TRIM are utilized. It is 
              assumed if the drive is connected via PCI-Express, the operating system supports TRIM over that channel.
              It is assumed the drive is healthy and contains minimal corrupted data and will be end of life before a 
              significant amount of damage to drive health occurs, it is assumed there is a risk small amounts of 
              potentially recoverable data may remain in damaged areas of the drive.<h:br/><h:br/>
              Finally, it is assumed the keys are not stored using a method that would be inaccessible to TRIM, such 
              as being contained in a file less than 982 bytes which would be completely contained in the master file
              table.<h:br/><h:br/>
              For destruction on wear-leveled memory, if a time period is required before is processed destruction the
              ST author shall provide an estimated range.
            </Guidance>
            <Tests>
              For these tests the evaluator shall use appropriate development environment (e.g. a Virtual Machine) and
              development tools (debuggers, simulators, etc.) to test that keys are cleared, including all copies of 
              the key that may have been created internally by the TOE during normal cryptographic processing with that
              key.<h:br/><h:br/>
              For destruction on wear-leveled memory, if a time period is required before is evaluator shall wait that 
              amount of time after clearing the key in tests 2 and 3.
              <testlist>
                <test>Applied to each key held as plaintext in volatile memory and subject to destruction by overwrite
                  by the TOE (whether or not the plaintext value is subsequently encrypted for storage in volatile or 
                  non-volatile memory). In the case where the only selection made for the destruction method key was 
                  removal of power, then this test is unnecessary. The evaluator shall:<h:ol type="1">
                    <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>
                    <h:li>Cause the TOE to stop the execution but not exit.</h:li>
                    <h:li>Cause the TOE to dump the entire memory of the TOE into a binary file.</h:li>
                    <h:li>Search the content of the binary file created in Step #5 for instances of the known key value from Step #1.</h:li>
                    <h:li>Break the key value from Step #1 into three similar sized pieces and perform a search using each piece.</h:li>
                  </h:ol>
                  Steps 1-6 ensure that the complete key does not exist anywhere in volatile memory. If a copy is found,
                  then the test fails.<h:br/><h:br/>
                  Step 7 ensures that partial key fragments do not remain in memory. If a fragment is found, there is a 
                  miniscule chance that it is not within the context of a key (e.g., some random bits that happen to match).
                  If this is the case the test should be repeated with a different key in Step #1. If a fragment is found 
                  the test fails.
                </test>
                
                <test>
                  Applied to each key held in non-volatile memory and subject to destruction by overwrite by the TOE. The 
                  evaluator shall use special tools (as needed), provided by the TOE developer if necessary, to view the key storage location:<h:ol type="1">
                    <h:li>Record the value of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>                    
                    <h:li>Search the non-volatile memory the key was stored in for instances of the known key value from Step #1. If a copy is found, then the test fails.</h:li>
                    <h:li>Break the key value from Step #1 into three similar sized pieces and perform a search using each 
                      piece. If a fragment is found then the test is repeated (as described for Use
                      test 1 above), and if a fragment is found in the repeated test then the test fails.</h:li>
                  </h:ol>
                </test>
                <test>
                  Applied to each key held as non-volatile memory and subject to destruction by overwrite by the TOE. 
                  The evaluator shall use special tools (as needed), provided by the TOE developer if necessary, to view the key storage location:<h:ol type="1">
                    <h:li>Record the logical storage location of the key in the TOE subject to clearing.</h:li>
                    <h:li>Cause the TOE to perform a normal cryptographic processing with the key from Step #1.</h:li>
                    <h:li>Cause the TOE to clear the key.</h:li>
                    <h:li>Read the logical storage location in Step #1 of non-volatile memory to
                      ensure the appropriate pattern is used.</h:li>
                  </h:ol>
                  The test succeeds if the correct pattern is used to overwrite the key in the
                  memory location. If the pattern is not found, the test fails. 
                </test>
              </testlist>              
            </Tests>
          </aactivity>
        </f-element>
      </f-component>
      
      <f-component name="Cryptographic Key Destruction Types" cc-id="fcs_ckm_ext.6" id="fcs-ckm-ext-6">
        <consistency-rationale/>
        <comp-lev>provides the TOE with the ability to select between multiple methods of key destruction.</comp-lev>
        <management/>
        <audit/>
        <dependencies>FCS_CKM.6 Cryptographic Key and Key Material Destruction</dependencies>
        
        <f-element id="fcs_ckm-ext-6">
          <title>
            The TSF shall use <selectables>
              <selectable>FCS_CKM.6<h:b>/GENHW</h:b></selectable>
              <selectable>FCS_CKM.6<h:b>/SW</h:b></selectable>
              <selectable>FCS_CKM.6<h:b>/TOEHW</h:b></selectable>
              
            </selectables>
            key destruction methods.
          </title>
          
          <ext-comp-def-title>
            <title>
              The TSF shall use <assignable>one or more iterations of FCS_CKM.4 defined elsewhere in
                the Security Target </assignable> key destruction methods.
            </title>
          </ext-comp-def-title>
          
          <note role="application">
            The specific key destruction methods that will be claimed are dependent on the
            selections made for where keys are stored.<h:br/><h:br/>
            If multiple selections are made, the TSS should identify which keys are destroyed
            according to which selections.
          </note>
         <aactivity>
            <TSS>
              (Key Management Description may be used if necessary details describe proprietary information)<h:br/><h:br/>
              The evaluator shall examine the TOE’s keychain in the TSS/KMD and verify all keys subject to destruction 
              are destroyed according to one of the specified methods.
            </TSS>
            <Guidance/>
            <Tests/>
          </aactivity>
        </f-element>
      </f-component>
      
        
            <f-component cc-id="fcs_cop.1" iteration="Hash" name="Cryptographic Operation (Hash Algorithm)" id="fcs-cop-1-hash">
              <f-element id="fcs_cop-1-1-hash">
                <title>
                  The TSF shall perform [<h:i>cryptographic hashing services</h:i>] in accordance with a specified cryptographic algorithm <selectables>
                    <selectable>SHA-256</selectable>
                    <selectable>SHA-384</selectable>
                    <selectable>SHA-512</selectable>
                  </selectables> <h:s>and cryptographic key sizes <assignable>cryptographic key sizes</assignable></h:s> that meet the following: [<h:i>ISO/IEC 10118-3:2004</h:i>]
                </title>
                <note role="application">
                  The selection should be consistent with the overall strength of the algorithm used for FCS_COP.1/SigVer and quantum resistant recommendations. For example,
                  SHA-256 should be chosen for 2048-bit RSA or ECC with P-256, SHA-384 should be chosen for 3072-bit RSA, 4096-bit RSA, or ECC with P-384, and SHA-512 should
                  be chosen for ECC with P-521. The selection of the standard is made based on the algorithms selected.<h:br/><h:br/>
                  
                  This SFR is required for the use of verifying digital signatures for trusted updates (FPT_TUD_EXT.1). It may also be used when the TSF performs validation
                  of a submask, intermediate key, or BEV by using a hash operation (FCS_VAL_EXT.1).
                </note>
                <aactivity>
                    <TSS>The evaluator shall check that the association of the hash function with other TSF
                      cryptographic functions (for example, the digital signature verification function) is
                      documented in the TSS.</TSS>
                    <Guidance>The evaluator checks the operational guidance documents to determine that any system
                      configuration necessary to enable required hash size functionality is provided.</Guidance>
                    <CustomEA name="KMD">There are no KMD evaluation activities for this SFR.</CustomEA>
                    <Tests>
                      <h:p>The TSF hashing functions can be implemented in one of two modes. The first mode
                        is the byte-oriented mode. In this mode the TSF only hashes messages that are an
                        integral number of bytes in length; i.e., the length (in bits) of the message to be hashed
                        is divisible by 8. The second mode is the bit-oriented mode. In this mode the TSF
                        hashes messages of arbitrary length. As there are different tests for each mode, an
                        indication is given in the following sections for the bit-oriented vs. the byte-oriented
                        test mode.</h:p>
                      <h:p>
                        The evaluator shall perform all of the following tests for each hash algorithm implemented by the TSF and used to satisfy the requirements of this cPP.
                      </h:p>
                      <h:p><h:u>Short Messages Test Bit-oriented Mode</h:u></h:p>
                      <h:p>The evaluators devise an input set consisting of m+1 messages, where m is the block
                        length of the hash algorithm. The length of the messages range sequentially from 0 to
                        m bits. The message text shall be pseudorandomly generated. The evaluators compute
                        the message digest for each of the messages and ensure that the correct result is
                        produced when the messages are provided to the TSF.</h:p>
                        <h:p><h:u>Short Messages Test Byte-oriented Mode</h:u></h:p>
                        <h:p>The evaluators devise an input set consisting of m/8+1 messages, where m is the block
                          length of the hash algorithm. The length of the messages range sequentially from 0 to
                          m/8 bytes, with each message being an integral number of bytes. The message text shall
                          be pseudorandomly generated. The evaluators compute the message digest for each of
                          the messages and ensure that the correct result is produced when the messages are
                          provided to the TSF.</h:p>
                        <h:p><h:u>Selected Long Messages Test Bit-oriented Mode</h:u></h:p>
                        <h:p>The evaluators devise an input set consisting of m messages, where m is the block
                          length of the hash algorithm. For SHA-256, the length of the i-th message is 512 +
                          99*i, where 1 ≤ i ≤ m. For SHA-384 and SHA-512, the length of the i-th message is
                          1024 + 99*i, where 1 ≤ i ≤ m. The message text shall be pseudorandomly generated.
                          The evaluators compute the message digest for each of the messages and ensure that
                          the correct result is produced when the messages are provided to the TSF.</h:p>
                        <h:p><h:u>Selected Long Messages Test Byte-oriented Mode</h:u></h:p>
                        <h:p>The evaluators devise an input set consisting of m/8 messages, where m is the block
                          length of the hash algorithm. For SHA-256, the length of the i-th message is 512 +
                          8*99*i, where 1 ≤ i ≤ m/8. For SHA-384 and SHA-512, the length of the i-th message
                          is 1024 + 8*99*i, where 1 ≤ i ≤ m/8. The message text shall be pseudorandomly
                          generated. The evaluators compute the message digest for each of the messages and
                          ensure that the correct result is produced when the messages are provided to the TSF.</h:p>
                        <h:p><h:u>Pseudorandomly Generated Messages Test</h:u></h:p>
                        <h:p>This test is for byte-oriented implementations only. The evaluators randomly generate
                          a seed that is n bits long, where n is the length of the message digest produced by the
                          hash function to be tested. The evaluators then formulate a set of 100 messages and
                          associated digests by following the algorithm provided in Figure 1 of the NIST Secure
                          Hash Algorithm Validation System (SHAVS)
                          (https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-ValidationProgram/documents/shs/SHAVS.pdf). The evaluators then ensure that the correct
                          result is produced when the messages are provided to the TSF.</h:p></Tests>
                </aactivity>
              </f-element>
          
            </f-component>
        
        <f-component cc-id="fcs_cop.1" iteration="KeyedHash" name="Cryptographic Operation (Keyed Hash Algorithm)" id="fcs-cop-1-keyhash" status="sel-based">
          <depends on-sel="fcs-val-ext-1-1-keyhash"/>
          <depends on-sel="sel-fcs-kyc-ext-1-1-sel-4"/>
          <f-element id="fcs_cop-1-1-keyhash">
            <title>
              The TSF shall perform  [<h:i>cryptographic keyed-hash message authentication</h:i>] in accordance with a specified cryptographic
              algorithm <selectables>
                <selectable>HMAC-SHA-256</selectable>
                <selectable>HMAC-SHA-384</selectable>
                <selectable>HMAC-SHA-512</selectable>
                <selectable>CMAC-AES-128</selectable>
                <selectable>CMAC-AES-256</selectable>
              </selectables> and <selectables>
                  <selectable>HMAC</selectable>
                  <selectable>AES</selectable>
                </selectables> key sizes <assignable>key size (in bits)</assignable> that meet the following: <selectables>
                  <selectable>ISO/IEC 9797-2:2011, Section 7 “MAC Algorithm 2”</selectable>
                  <selectable>NIST SP 800-38B</selectable></selectables>.
            </title>
            <note role="application">
              The key size [k] in the assignment falls into a range between L1 and L2 (defined in ISO/IEC 10118 for the appropriate hash function for
              example for SHA-256 L1 = 512, L2 =256) where L2 ≤ k ≤ L1.<h:br/><h:br/>
              
              This SFR is required when the TSF performs a key derivation operation as part of maintaining and deriving a key chain (FCS_KDF_EXT.1, 
              FCS_KYC_EXT.1) or when the TSF performs validation of a submask, intermediate key, or BEV using a keyed hash operation (FCS_VAL_EXT.1).
            </note>
            <aactivity>
              <TSS>
                <h:p>
                  If HMAC was selected:
                </h:p>
                <h:p>
                  The evaluator shall examine the TSS to ensure that it specifies the following values
                  used by the HMAC function: key length, hash function used, block size, and output
                  MAC length used.
                </h:p>
                <h:p>If CMAC was selected: </h:p>
                <h:p>The evaluator shall examine the TSS to ensure that it specifies the following
                  values used by the CMAC function: key length, block cipher used, block size
                  (of the cipher), and output MAC length used.</h:p></TSS>
              <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
              <CustomEA name="KMD">There are no KMD evaluation activities for this SFR.</CustomEA>
              <Tests>
                <h:p>If HMAC was selected:</h:p>
                <h:p>For each of the supported parameter sets, the evaluator shall compose 15 sets of test
                  data. Each set shall consist of a key and message data. The evaluator shall have the TSF
                  generate HMAC tags for these sets of test data. The resulting MAC tags shall be
                  compared to the result of generating HMAC tags with the same key using a known
                  good implementation.</h:p>
                <h:p>
                  If CMAC was selected: 
                </h:p>
                <h:p>For each of the supported parameter sets, the evaluator shall compose at least
                  15 sets of test data. Each set shall consist of a key and message data. The test
                  data shall include messages of different lengths, some with partial blocks as the
                  last block and some with full blocks as the last block. The test data keys shall
                  include cases for which subkey K1 is generated both with and without using the
                  irreducible polynomial R_b, as well as cases for which subkey K2 is generated
                  from K1 both with and without using the irreducible polynomial R_b. (The
                  subkey generation and polynomial R_b are as defined in SP800-38E.) The
                  evaluator shall have the TSF generate CMAC tags for these sets of test data.
                  The resulting MAC tags shall be compared to the result of generating CMAC
                  tags with the same key using a known good implementation.</h:p></Tests>
            </aactivity>
          </f-element>
          
        </f-component>
        
        <f-component cc-id="fcs_cop.1" iteration="KeyEnc" name="Cryptographic Operation (Key Encryption)" id="fcs-cop-1-kE" status="sel-based">
          <depends on-sel="sel-fcs-kyc-ext-1-1-sel-1"/>
          <depends on-sel="fcs-pcc-ext-1-2-sel-2"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-2"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3cii"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eii"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eiv"/>
          <f-element id="fcs_cop-1-1-kE">
            <title>
              The TSF shall perform [<h:i>key encryption and decryption</h:i>] in accordance with a specified cryptographic algorithm [<h:i>AES used in <selectables><selectable>CBC</selectable><selectable>GCM</selectable></selectables> mode</h:i>] and cryptographic key sizes <selectables><selectable>128 bits</selectable><selectable>256 bits</selectable></selectables> that meet the following: [<h:i>AES as specified in ISO /IEC 18033-3,</h:i> <selectables><selectable>CBC as specified in ISO/IEC 10116</selectable><selectable>GCM as specified in ISO/IEC 19772</selectable></selectables>].
            </title>
            <note role="application">
              This requirement is used in the body of the ST if the ST author chooses to use AES encryption/decryption for protecting the keys as part of the key chaining
              approach that is specified in FCS_KYC_EXT.1.<h:br/><h:br/>
              
              This SFR is required when the TSF performs key encryption as part of maintaining and deriving a key chain (FCS_KDF_EXT.1, FCS_KYC_EXT.1) or when the TSF
              uses key encryption as part of password conditioning.
            </note>
            <aactivity>
              <TSS>The evaluator shall verify the TSS includes a description of the key size used for
                encryption and the mode used for the key encryption.</TSS>
              <Guidance>If multiple key encryption modes are supported, the evaluator examines the guidance
                documentation to determine that the method of choosing a specific mode/key size by
                the end user is described.</Guidance>
              <CustomEA name="KMD">The evaluator shall examine the vendor’s KMD to verify that it includes a description
                of how key encryption will be used as part of the key chain.</CustomEA>
              <Tests>The AES test should be followed in FCS_COP.1/SKC Cryptographic Operation (AES
                Data Encryption/Decryption.</Tests>
            </aactivity>
          </f-element>
          
        </f-component>
        
        <f-component cc-id="fcs_cop.1" iteration="KeyEncap" name="Cryptographic Operation (Key Transport)" id="fcs-cop-1-keyencap" status="sel-based">
          <depends on-sel="sel-fcs-kyc-ext-1-1-sel-2"/>
          <depends on-sel="fcs-pcc-ext-1-2-sel-2"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-2"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3cii"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eii"/>
          <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eiv"/>
          <f-element id="fcs_cop-1-1-keyencap">
            <title>
              The TSF shall perform [<h:i>key transport</h:i>] in accordance with a specified
              cryptographic algorithm [<h:i>RSA in the following modes <selectables><selectable>KTS-OAEP</selectable><selectable>KTS-KEM-KWS</selectable></selectables></h:i> and the cryptographic key size <h:i><selectables>
                <selectable>2048 bits</selectable>
                <selectable>3072 bits</selectable>
              </selectables></h:i> that meet the following: [<h:i>NIST SP 800-56B, Revision 1</h:i>].
            </title>
            <note role="application">
              This requirement is used in the body of the ST if the ST author chooses to use key transport in the key chaining approach that is specified in 
              FCS_KYC_EXT.1.<h:br/><h:br/>
              
              This SFR is required when the TSF performs key encryption as part of maintaining and deriving a key chain (FCS_KDF_EXT.1, FCS_KYC_EXT.1) or
              when the TSF uses key encryption as part of password conditioning.
            </note>
            <aactivity>
              <TSS>
                <h:p>The evaluator shall verify the TSS provides a high level description of the RSA scheme
                  and the cryptographic key size that is being used, and that the asymmetric algorithm
                  being used for key transport is RSA. If more than one scheme/key size are allowed,
                  then the evaluator shall make sure and test all combinations of scheme and key size.
                  There may be more than one key size to specify – an RSA modulus size (and/or
                  encryption exponent size), an AES key size, hash sizes, MAC key/MAC tag size.</h:p>
                <h:p>If the KTS-OAEP scheme was selected, the evaluator shall verify that the TSS
                  identifies the hash function, the mask generating function, the random bit generator,
                  the encryption primitive and decryption primitive.</h:p>
                <h:p>If the KTS-KEM-KWS scheme was selected, the evaluator shall verify that the TSS
                  identifies the key derivation method, the AES-based key wrapping method, the secret
                  value encapsulation technique, and the random number generator.</h:p></TSS>
              <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
              <CustomEA name="KMD">There are no KMD evaluation activities for this SFR.</CustomEA>
              <Tests>
                <h:p>For each supported key transport schema, the evaluator shall initiate at least 25 sessions
                  that require key transport with an independently developed remote instance of a key
                  transport entity, using known RSA key-pairs. The evaluator shall observe traffic passed
                  from the sender-side and to the receiver-side of the TOE, and shall perform the
                  following tests, specific to which key transport scheme was employed.</h:p>
                <h:p>
                  If the KTS-OAEP scheme was selected, the evaluator shall perform the following tests:<testlist>
                    <test>The evaluator shall inspect each cipher text, C, produced by the RSA-OAEP
                      encryption operation of the TOE and make sure it is the correct length, either 256
                      or 384 bytes depending on RSA key size. The evaluator shall also feed into the
                      TOE’s RSA-OEAP decryption operation some cipher texts that are the wrong
                      length and verify that the erroneous input is detected and that the decryption
                      operation exits with an error code.</test>
                    <test>The evaluator shall convert each cipher text, C, produced by the RSA-OAEP
                      encryption operation of the TOE to the correct cipher text integer, c, and use the
                      decryption primitive to compute em = RSADP((n,d),c) and convert em to the
                      encoded message EM. The evaluator shall then check that the first byte of EM is
                      0x00. The evaluator shall also feed into the TOE’s RSA-OEAP decryption
                      operation some cipher texts where the first byte of EM was set to a value other
                      than 0x00, and verify that the erroneous input is detected and that the decryption
                      operation exits with an error code.</test>
                    <test>The evaluator shall decrypt each cipher text, C, produced by the RSA-OAEP
                      encryption operation of the TOE using RSADP, and perform the OAEP decoding
                      operation (described in NIST SP 800-56B section 7.2.2.4) to recover HA’ || X. For
                      each HA’, the evaluator shall take the corresponding A and the specified hash
                      algorithm and verify that HA' = Hash(A). The evaluator shall also force the TOE
                      to perform some RSA-OAEP decryptions where the A value is passed incorrectly,
                      and the evaluator shall verify that an error is detected.</test>
                    <test>The evaluator shall check the format of the ‘X’ string recovered in OAEP.Test.3
                      to ensure that the format is of the form PS || 01 || K, where PS consists of zero or
                      more consecutive 0x00 bytes and K is the transported keying material. The
                      evaluator shall also feed into the TOE’s RSA-OEAP decryption operation some
                      cipher texts for which the resulting ‘X’ strings do not have the correct format (i.e.,
                      the leftmost non-zero byte is not 0x01). These incorrectly formatted ‘X’ variables
                      shall be detected by the RSA-OEAP decrypt function.
                    </test>
                    <test>The evaluator shall trigger all detectable decryption errors and validate that the
                      returned error codes are the same and that no information is given back to the
                      sender on which type of error occurred. The evaluator shall also validate that no
                      intermediate results from the TOE’s receiver-side operations are revealed to the
                      sender.</test>
                  </testlist>
                </h:p>
                <h:p>If the KTS-KEM-KWS scheme was selected, the evaluator shall perform the following
                  tests:<testlist>
                    <test>The evaluator shall inspect each cipher text, C, produced by RSA-KEM-KWS
                      encryption operation of the TOE and make sure the length (in bytes) of the cipher
                      text, cLen, is greater than nLen (the length, in bytes, of the modulus of the RSA
                      public key) and that cLen - nLen is consistent with the byte lengths supported by
                      the key wrapping algorithm. The evaluator shall feed into the RSA-KEM-KWS
                      decryption operation a cipher text of unsupported length and verify that an error
                      is detected and that the decryption process stops.</test>
                    <test>The evaluator shall separate the cipher text, C, produced by the sender-side of the
                      TOE into its C0 and C1 components and use the RSA decryption primitive to
                      recover the secret value, Z, from C0. The evaluator shall check that the unsigned
                      integer represented by Z is greater than 1 and less than n-1, where n is the modulus
                      of the RSA public key. The evaluator shall construct examples where the cipher
                      text is created with a secret value Z = 1 and make sure the RSA-KEM-KWS
                      decryption process detects the error. Similarly, the evaluator shall construct
                      examples where the cipher text is created with a secret value Z = n – 1 and make
                      sure the RSA-KEM-KWS decryption process detects the error.</test>
                    <test>The evaluator shall attempt to successfully recover the secret value Z, derive the
                      key wrapping key, KWK, and unwrap the KWA-cipher text following the RSAKEM-KWS
                      decryption process given in NIST SP 800-56B section 7.2.3.4. If the
                      key-wrapping algorithm is AES-CCM, the evaluator shall verify that the value of
                      any (unwrapped) associated data, A, that was passed with the wrapped keying
                      material is correct The evaluator shall feed into the TOE’s RSA-KEM-KWS
                      decryption operation examples of incorrect cipher text and verify that a decryption
                      error is detected. If the key-wrapping algorithm is AES-CCM, the evaluator shall
                      attempt at least one decryption where the wrong value of A is given to the RSAKEM-KWS decryption operation and verify that a decryption error is detected.
                      Similarly, if the key-wrapping algorithm is AES-CCM, the evaluator shall attempt
                      at least one decryption where the wrong nonce is given to the RSA-KEM-KWS
                      decryption operation and verify that a decryption error is detected.</test>
                    <test>The evaluator shall trigger all detectable decryption errors and validate that the
                      resulting error codes are the same and that no information is given back to the
                      sender on which type of error occurred. The evaluator shall also validate that no
                      intermediate results from the TOE’s receiver-side operations (in particular, no Z
                      values) are revealed to the sender.</test>
                  </testlist></h:p></Tests>
            </aactivity>
          </f-element>
          
        </f-component>
        
            
            <f-component cc-id="fcs_cop.1" iteration="KeyWrap" name="Cryptographic Operation (Key Wrapping)" id="fcs-cop-1-keywrap" status="sel-based">
              <depends on-sel="sel-fcs-kyc-ext-1-1-sel-4"/>
              <depends on-sel="sel-fcs-val-ext-1-1-sel-2a"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-2"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3cii"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eii"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3eiv"/>
              <f-element id="fcs_cop-1-1-keywrap">
                
                <title>
                  The TSF shall perform [<h:i>key wrapping</h:i>] in accordance with a specified cryptographic algorithm [<h:i>AES</h:i>] <h:b>in the following modes <selectables>
                    <selectable>KW</selectable>
                    <selectable>KWP</selectable>
                    <selectable>GCM</selectable>
                    <selectable>CCM</selectable>

                  </selectables></h:b> and cryptographic key size <selectables><selectable>128 bits</selectable><selectable>256 bits</selectable></selectables> that meet the following: [<h:i>AES as specified in ISO/IEC 18033-3, <selectables>
                    <selectable>NIST SP 800-38F</selectable>
                    <selectable>ISO/IEC 19772</selectable>
                    <selectable>no other standards</selectable>
                  </selectables></h:i>].
                </title>
                <note role="application">
                  This requirement is used in the body of the ST if the ST author chooses to use key wrapping in the key chaining approach that is specified in 
                  FCS_KYC_EXT.1.<h:br/><h:br/>
                  
                  This SFR is required when the TSF performs key wrapping as part of maintaining and deriving a key chain (FCS_KDF_EXT.1, FCS_KYC_EXT.1) or
                  when the TSF performs validation of a submask, intermediate key, or BEV using a key wrap operation (FCS_VAL_EXT.1).                
                </note>
                <aactivity>
                    <TSS>The evaluator shall verify the TSS includes a description of the key wrap functions
                      and shall verify the key wrap uses an approved key wrap algorithm according to the
                      appropriate specification.</TSS>
                    <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
                    <CustomEA name="KMD">The evaluator shall review the KMD to ensure that all keys are wrapped using the
                      approved method and a description of when the key wrapping occurs.</CustomEA>                      
                    <Tests>There are no test evaluation activities for this SFR.</Tests>
                </aactivity>
              </f-element>
          
            </f-component>
            
           
        <f-component cc-id="fcs_cop.1" iteration="SigVer" name="Cryptographic Operation (Signature Verification)" id="fcs-cop-1-sigver">
          
          <f-element id="fcs_cop-1-1-sigver">            
            <title>The TSF shall perform [<h:i>cryptographic signature services
              (verification)</h:i>] in accordance with a specified cryptographic
                algorithm <h:b><selectables linebreak='yes'>
              <selectable>RSA Digital Signature Algorithm with a key size (modulus) of <selectables><selectable>2048-bit</selectable><selectable>3072-bit</selectable><selectable>4096-bit</selectable></selectables></selectable>
              <selectable>Elliptic Curve Digital Signature Algorithm with a key size of [<h:i>256 bits or greater</h:i>]</selectable>
            </selectables></h:b> 
              that meet the following: <selectables linebreak='yes'>
                <selectable>FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Section 5.5, using PKCS #1 v2.1 Signature Schemes RSASSA-PSS and/or RSASSA-PKCS1-v1_5; ISO/IEC 9796-2, Digital signature scheme 2 or Digital Signature scheme 3, for RSA schemes</selectable>
                <selectable>FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Section 6 and Appendix D, Implementing “NIST curves” <selectables>
                  <selectable>P-256</selectable>
                  <selectable>P-384</selectable>
                  <selectable>P-521</selectable></selectables> ISO/IEC 14888-3, Section 6.4, for ECDSA schemes
                </selectable>
              </selectables>.
            </title>
            <note role="application">
              The selection should be consistent with the overall strength of the algorithm used for FCS_COP.1/SigVer and quantum resistant recommendations. For example, 
              SHA-256 should be chosen for 2048-bit RSA or ECC with P-256, SHA-384 should be chosen for 3072-bit RSA, 4096-bit RSA, or ECC with P-384, and SHA-512 should
              be chosen for ECC with P9 521. The selection of the standard is made based on the algorithms selected.<h:br/><h:br/>
              This SFR is mandatory for its use in verification of digital signatures for TOE updates. It may also be used when the TSF performs validation of a submask,
              intermediate key, or BEV by using a digital signature operation (FCS_VAL_EXT.1).
            </note>
            <aactivity>
              <h:p>This requirement is used to verify digital signatures attached to updates from the TOE
                manufacturer before installing those updates on the TOE. Because this component is to
                be used in the update function, additional Evaluation Activities to those listed below
                are covered in other evaluation activities sections in this document. The following
                activities deal only with the implementation for the digital signature algorithm; the
                evaluator performs the testing appropriate for the algorithms selected in the
                component.
              </h:p>
              <h:p>Hash functions and/or random number generation required by these algorithms must
                be specified in the ST; therefore the Evaluation Activities associated with those
                functions are contained in the associated Cryptographic Hashing and Random Bit
                Generation sections. Additionally, the only function required by the TOE is the
                verification of digital signatures. If the TOE generates digital signatures to support the
                implementation of any functionality required by this cPP, then the applicable
                evaluation and validation scheme must be consulted to determine the required
                evaluation activities.</h:p>
              <TSS>The evaluator shall check the TSS to ensure that it describes the overall flow of the
                signature verification. This should at least include identification of the format and
                general location (e.g., "firmware on the hard drive device" rather than “memory
                location 0x00007A4B") of the data to be used in verifying the digital signature; how
                the data received from the operational environment are brought on to the device; and
                any processing that is performed that is not part of the digital signature algorithm (for
                instance, checking of certificate revocation lists).</TSS>
              <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
              <CustomEA name="KMD">There are no KMD evaluation activities for this SFR.</CustomEA>
              <Tests>
                <h:p>Each section below contains the tests the evaluators must perform for each type of
                  digital signature scheme. Based on the assignments and selections in the requirement,
                  the evaluators choose the specific activities that correspond to those selections.</h:p>
                <h:p>It should be noted that for the schemes given below, there are no key generation/domain
                  parameter generation testing requirements. This is because it is not anticipated that this
                  functionality would be needed in the end device, since the functionality is limited to
                  checking digital signatures in delivered updates. This means that the domain
                  parameters should have already been generated and encapsulated in the hard drive
                  firmware or on-board non-volatile storage. If key generation/domain parameter
                  generation is required, the evaluation and validation scheme must be consulted to
                  ensure the correct specification of the required evaluation activities and any additional
                  components.</h:p>
                <h:p>The following tests are conditional based upon the selections made within the SFR.</h:p>
                <h:p>The following tests may require the developer to provide access to a test platform that
                  provides the evaluator with tools that are typically not found on factory products.</h:p>
                <h:p><h:u>ECDSA Algorithm Tests</h:u></h:p>
                <h:p><h:b>ECDSA FIPS 186-4 Signature Verification Test</h:b></h:p>
                <h:p>For each supported NIST curve (i.e., P-256, P-384 and P-521) and SHA function pair,
                  the evaluator shall generate a set of 10 1024-bit message, public key and signature
                  tuples and modify one of the values (message, public key or signature) in five of the 10
                  tuples. The evaluator shall obtain in response a set of 10 PASS/FAIL values.</h:p>
                <h:p><h:u>RSA Signature Algorithm Tests</h:u></h:p>
                <h:p><h:b>Signature Verification Test</h:b></h:p>
                <h:p>The evaluator shall perform the Signature Verification test to verify the ability of the
                  TOE to recognize another party’s authentic and unauthentic signatures. The evaluator
                  shall inject errors into the test vectors produced during the Signature Verification Test
                  by introducing errors in some of the public keys e, messages, IR format, and/or
                  signatures. The TOE attempts to verify the signatures and returns success or failure.</h:p>
                <h:p>The evaluator shall use these test vectors to emulate the signature verification test using
                  the corresponding parameters and verify that the TOE detects these errors.</h:p>
              </Tests>
            </aactivity>
          </f-element>
          
        </f-component>
        
        <f-component cc-id="fcs_cop.1" iteration="SKC" name="Cryptographic Operation (AES Data Encryption/Decryption)" id="fcs-cop-1-skc" status="sel-based">
              <depends on-sel="fcs-val-ext-1-1-decr"/>
              <depends on-sel="sel-fcs-kyc-ext-1-1-sel-1"/>
              <depends on-sel="submask-derived"/>
              <depends on-sel="sel-fcs-val-ext-1-1-sel-2a"/>          

              <f-element id="fcs_cop-1-1-skc">
                <title>
                  The TSF shall perform [<h:i>data encryption and decryption</h:i>] in accordance with a specified cryptographic algorithm [<h:i>AES used in 
                    
                      <selectables>
                        <selectable>CBC</selectable>
                        <selectable>GCM</selectable>
                        <selectable>XTS</selectable>
                      </selectables>
                     mode</h:i>] and cryptographic key sizes 
                      <selectables>
                        <selectable>128 bits</selectable>
                        <selectable>256 bits</selectable>
                      </selectables> that meet the following: [<h:i>AES as specified in ISO /IEC 18033-3, 
                        <selectables>
                          <selectable>CBC as specified in ISO/IEC 10116</selectable>
                          <selectable>GCM as specified in ISO/IEC 19772</selectable>
                          <selectable>XTS as specified in IEEE 1619</selectable>
                        </selectables></h:i>].
                </title>
                <note role="application">
                  The intent of this requirement in the context of this cPP is to provide an SFR that expresses the appropriate symmetric encryption/decryption algorithms
                  suitable for use in the TOE. If the ST author incorporates the validation requirement (FCS_VAL_EXT.1) and chooses to select the option to decrypt a known
                  value and perform a comparison, this is the requirement used to specify the algorithm, modes, and key sizes the ST author can choose from.<h:br/><h:br/>
                  
                  When the XTS mode is selected, a cryptographic key of 256-bit or of 512-bit is allowed as specified in IEEE 1619. XTS-AES key is divided into two AES keys
                  of equal size - for example, AES-128 is used as the underlying algorithm, when 256-bit key and XTS mode are selected. AES-256 is used when a 512-bit key 
                  and XTS mode are selected.<h:br/><h:br/>
                  
                  This SFR is required when the TSF performs any key wrapping, key encryption, or key derivation operation as part of maintaining and deriving a key chain
                  (FCS_KDF_EXT.1, FCS_KYC_EXT.1), or when the TSF performs validation of a submask, intermediate key, or BEV using a symmetric encryption operation 
                  (FCS_VAL_EXT.1).
              
                </note>
                <aactivity>
                  <TSS>The evaluator shall verify the TSS includes a description of the key size used for
                    encryption and the mode used for encryption.</TSS>
                    <Guidance>If multiple encryption modes are supported, the evaluator examines the guidance
                      documentation to determine that the method of choosing a specific mode/key size by
                      the end user is described.</Guidance>
                    <CustomEA name="KMD">There are no KMD evaluation activities for this SFR.</CustomEA>
                    <Tests>
                      <h:p>The following tests are conditional based upon the selections made in the SFR.</h:p>
                      <h:p><h:b>AES-CBC Tests</h:b></h:p>
                      <h:p>For the AES-CBC tests described below, the plaintext, ciphertext, and IV values shall
                        consist of 128-bit blocks. To determine correctness, the evaluator shall compare the
                        resulting values to those obtained by submitting the same inputs to a known-good
                        implementation.</h:p>
                        <h:p>These tests are intended to be equivalent to those described in NIST’s AES Algorithm
                          Validation Suite (AESAVS)
                          (http://csrc.nist.gov/groups/STM/cavp/documents/aes/AESAVS.pdf). Known answer
                          values tailored to exercise the AES-CBC implementation can be obtained using NIST’s
                          CAVS Algorithm Validation Tool or from NIST’s ACPV service for automated
                          algorithm tests (acvp.nist.gov), when available. It is not recommended that evaluators
                          use values obtained from static sources such as the example NIST’s AES Known
                          Answer Test Values from the AESAVS document, or use values not generated
                          expressly to exercise the AES-CBC implementation.</h:p>
                      <h:p><h:b>AES-CBC Known Answer Tests</h:b></h:p>
                      <h:p>KAT-1 (GFSBox):</h:p>
                      <h:p>To test the encrypt functionality of AES-CBC, the evaluator shall supply a set of five
                        different plaintext values for each selected key size and obtain the ciphertext value that
                        results from AES-CBC encryption of the given plaintext using a key value of all zeros
                        and an IV of all zeros.
                      </h:p>
                      <h:p>To test the decrypt functionality of AES-CBC, the evaluator shall supply a set of five
                        different ciphertext values for each selected key size and obtain the plaintext value that
                        results from AES-CBC decryption of the given ciphertext using a key value of all zeros
                        and an IV of all zeros.</h:p>
                      <h:p>KAT-2 (KeySBox):</h:p>
                      <h:p>To test the encrypt functionality of AES-CBC, the evaluator shall supply a set of five
                        different key values for each selected key size and obtain the ciphertext value that
                        results from AES-CBC encryption of an all-zeros plaintext using the given key value
                        and an IV of all zeros.</h:p>
                      <h:p>To test the decrypt functionality of AES-CBC, the evaluator shall supply a set of five
                          different key values for each selected key size and obtain the plaintext that results from
                          AES-CBC decryption of an all-zeros ciphertext using the given key and an IV of all
                          zeros.</h:p>
                      <h:p>KAT-3 (Variable Key):</h:p>
                      <h:p>To test the encrypt functionality of AES-CBC, the evaluator shall supply a set of keys
                            for each selected key size (as described below) and obtain the ciphertext value that
                            results from AES encryption of an all-zeros plaintext using each key and an IV of all
                            zeros.</h:p>
                      <h:p>Key i in each set shall have the leftmost i bits set to ones and the remaining bits to
                              zeros, for values of i from 1 to the key size. The keys and corresponding ciphertext are
                              listed in AESAVS, Appendix E.</h:p>
                      <h:p>To test the decrypt functionality of AES-CBC, the evaluator shall use the same keys as
                        above to decrypt the ciphertext results from above. Each decryption should result in an
                        all-zeros plaintext.</h:p>
                      <h:p>KAT-4 (Variable Text):</h:p>
                      <h:p>To test the encrypt functionality of AES-CBC, for each selected key size, the evaluator
                        shall supply a set of 128-bit plaintext values (as described below) and obtain the
                        ciphertext values that result from AES-CBC encryption of each plaintext value using a
                        key of each size and IV consisting of all zeros.</h:p>
                      <h:p>Plaintext value i shall have the leftmost i bits set to ones and the remaining bits set to
                        zeros, for values of i from 1 to 128. The plaintext values are listed in AESAVS,
                        Appendix D.</h:p>
                      <h:p>To test the decrypt functionality of AES-CBC, for each selected key size, use the
                        plaintext values from above as ciphertext input, and AES-CBC decrypt each ciphertext
                        value using key of each size consisting of all zeros and an IV of all zeros.</h:p>
                      <h:p><h:b>AES-CBC Multi-Block Message Test</h:b></h:p>
                      <h:p>The evaluator shall test the encrypt functionality by encrypting nine i-block messages
                        for each selected key size, for 2 ≤ i ≤ 10. For each test, the evaluator shall supply a key,
                        an IV, and a plaintext message of length i blocks, and encrypt the message
                        using AES*CBC. The resulting ciphertext values shall be compared to the results of encrypting the
                        plaintext messages using a known good implementation</h:p>
                      <h:p>The evaluator shall test the decrypt functionality by decrypting nine i-block messages
                        for each selected key size, for 2 ≤ i ≤ 10. For each test, the evaluator shall supply a key,
                        an IV, and a ciphertext message of length i blocks, and decrypt the message
                        using AES*CBC. The resulting plaintext values shall be compared to the results of decrypting the
                        ciphertext messages using a known good implementation.</h:p>
                      <h:p><h:b>AES-CBC Monte Carlo Tests</h:b></h:p>
                      <h:p>The evaluator shall test the encrypt functionality for each selected key size using 100
                        3-tuples of pseudo-random values for plaintext, IVs, and keys.</h:p>
                      <h:p>The evaluator shall supply a single 3-tuple of pseudo-random values for each selected
                        key size. This 3-tuple of plaintext, IV, and key is provided as input to the below
                        algorithm to generate the remaining 99 3-tuples, and to run each 3-tuple through 1000
                        iterations of AES-CBC encryption.</h:p>
                      <h:p># Input: PT, IV, Key 
                        <h:br/>Key[0] = Key
                        <h:br/>IV[0] = IV
                        <h:br/>PT[0] = PT</h:p>
                      <h:p>for i = 1 to 100 {
                        <h:br/>   Output Key[i], IV[i], PT[0]
                        <h:br/>   for j = 1 to 1000 {
                        <h:br/>   if j == 1 {
                          <h:br/>      CT[1] = AES-CBC-Encrypt(Key[i], IV[i], PT[1])
                          <h:br/>      PT[2] = IV[i]
                        <h:br/>   } else {
                          <h:br/>      CT[j] = AES-CBC-Encrypt(Key[i], PT[j])
                          <h:br/>      PT[j+1] = CT[j-1]
                        <h:br/>   }
                        <h:br/>}
                        <h:br/>   Output CT[1000]</h:p>
                      <h:p>
                        <h:br/>   If KeySize == 128 { Key[i+1] = Key[i] xor CT[1000] }
                        <h:br/>   If KeySize == 256 { Key[i+1] = Key[i] xor ((CT[999] &lt;&lt; 128) | CT[1000]) }
                      </h:p>
                      <h:p>
                        <h:br/>   IV[i+1] = CT[1000]
                        <h:br/>   PT[0] = CT[999]
                         }</h:p>
                      <h:p>The ciphertext computed in the 1000th iteration (CT[1000]) is the result for each of the
                        100 3-tuples for each selected key size. This result shall be compared to the result of
                        running 1000 iterations with the same values using a known good implementation.</h:p>
                      <h:p>The evaluator shall test the decrypt functionality using the same test as above,
                        exchanging CT and PT, and replacing AES-CBC-Encrypt with AES-CBC-Decrypt.</h:p>
                      <h:p><h:b>AES-GCM Test</h:b></h:p>
                     
                      <h:p>The evaluator shall test the authenticated encrypt functionality of AES-GCM for each
                        combination of the following input parameter lengths:</h:p>
                      <h:p><h:b>   128 bit and 256 bit keys</h:b></h:p>
                      <h:p><h:b>   Two plaintext lengths.</h:b> One of the plaintext lengths shall be a non-zero integer multiple of 128 bits, if supported. The other plaintext length shall not be an integer multiple of 128 bits, if supported.</h:p>
                      <h:p><h:b>   Three AAD lengths.</h:b> One AAD length shall be 0, if supported. One AAD length
                      shall be a non-zero integer multiple of 128 bits, if supported. One AAD length shall
                      not be an integer multiple of 128 bits, if supported.</h:p>
                      <h:p><h:b>   Two IV lengths.</h:b> If 96 bit IV is supported, 96 bits shall be one of the two IV lengths
                      tested.</h:p>   
                      <h:p>The evaluator shall test the encrypt functionality using a set of 10 key, plaintext, AAD,
                        and IV tuples for each combination of parameter lengths above and obtain the
                        ciphertext value and tag that results from AES-GCM authenticated encrypt. Each
                        supported tag length shall be tested at least once per set of 10. The IV value may be
                        supplied by the evaluator or the implementation being tested, as long as it is known.</h:p>
                      <h:p>The evaluator shall test the decrypt functionality using a set of 10 key, ciphertext, tag,
                        AAD, and IV 5-tuples for each combination of parameter lengths above and obtain a
                        Pass/Fail result on authentication and the decrypted plaintext if Pass. The set shall
                        include five tuples that Pass and five that Fail.</h:p>
                      <h:p>The results from each test may either be obtained by the evaluator directly or by
                        supplying the inputs to the implementer and receiving the results in response. To
                        determine correctness, the evaluator shall compare the resulting values to those
                        obtained by submitting the same inputs to a known good implementation.</h:p>
                      <h:p><h:b>XTS-AES Test</h:b></h:p>
                      <h:p>The evaluator shall test the encrypt functionality of XTS-AES for each combination of
                        the following input parameter lengths:</h:p>
                      <h:p><h:b>   256 bit (for AES-128) and 512 bit (for AES-256) keys</h:b></h:p>
                      <h:p><h:b>   Three data unit (i.e., plaintext) lengths. </h:b>One of the data unit lengths shall be a
                      non-zero integer multiple of 128 bits, if supported. One of the data unit lengths
                      shall be an integer multiple of 128 bits, if supported. The third data unit length shall
                      be either the longest supported data unit length or 216 bits, whichever is smaller.</h:p>
                      <h:p>using a set of 100 (key, plaintext and 128-bit random tweak value) 3-tuples and obtain
                        the ciphertext that results from XTS-AES encrypt.</h:p>
                      <h:p>The evaluator may supply a data unit sequence number instead of the tweak value if
                        the implementation supports it. The data unit sequence number is a base-10 number
                        ranging between 0 and 255 that implementations convert to a tweak value internally</h:p>
                      <h:p>The evaluator shall test the decrypt functionality of XTS-AES using the same test as
                        for encrypt, replacing plaintext values with ciphertext values and XTS-AES encrypt
                        with XTS-AES decrypt.</h:p>
                    </Tests>
                </aactivity>
              </f-element>
          
            </f-component>
            

            <f-component cc-id="fcs_kdf_ext.1" name="Cryptographic Key Derivation" id="fcs-kdf-ext-1" status="sel-based">
              <depends on="fcs-kyc-ext-2-2-sel-1"/>
              <consistency-rationale/>
              <comp-lev>requires the TSF to derive intermediate keys from submasks using the specified hash functions.</comp-lev>
              <management/>
              <audit/>
              <dependencies>FCS_COP.1 Cryptographic Operation</dependencies>
              
              <f-element id="fcs-kdf-ext-1">
                <title>
                  The TSF shall accept <selectables>
                    <selectable id="sel-fcs-kdf-ext-1-1-sel-1a">an RNG generated submask as specified in FCS_RBG.1</selectable>
                    <selectable id="sel-fcs-kdf-ext-1-1-sel-1b">a conditioned password submask</selectable>
                    <selectable id="sel-fcs-kdf-ext-1-1-sel-1c">imported submask</selectable>
                  </selectables> to derive an intermediate key, as defined in <selectables linebreak='yes'>
                    <selectable id="sel-fcs-kdf-ext-1-1-sel-2">NIST SP 800-108 <selectables>
                      <selectable id="sel-fcs-kdf-ext-1-1-sel-2a">KDF in Counter Mode</selectable>
                      <selectable id="sel-fcs-kdf-ext-1-1-sel-2b">KDF in Feedback Mode</selectable>
                      <selectable id="sel-fcs-kdf-ext-1-1-sel-2c">KDF in Double-Pipeline Iteration Mode</selectable>
                    </selectables></selectable>
                    <selectable id="sel-fcs-kdf-ext-1-1-sel-3">NIST SP 800-132</selectable>
                  </selectables> using the keyed-hash functions specified in FCS_COP.1<h:b>/KeyedHash</h:b>, such that the output is at least of equivalent security strength (in number of bits) to the BEV.

                </title>
                
                <ext-comp-def-title>
                  <title>The TSF shall accept <selectables>
                    <selectable>an RNG generated submask as specified in FCS_RBG.1</selectable>
                    <selectable>a conditioned password submask</selectable>
                    <selectable>imported submask</selectable>
                  </selectables> to derive an intermediate key, as defined in <selectables linebreak='yes'>
                    <selectable>NIST SP 800-108 <selectables>
                      <selectable>KDF in Counter Mode</selectable>
                      <selectable>KDF in Feedback Mode</selectable>
                      <selectable>KDF in Double-Pipeline Iteration Mode</selectable>
                    </selectables></selectable>
                    <selectable>NIST SP 800-132</selectable>
                  </selectables> using the keyed-hash functions specified in FCS_COP.1, such that the output is at least of equivalent security strength (in number of bits) to the BEV.
                    
                  </title>
                </ext-comp-def-title>
                <note role="application">
                  <h:p>This requirement is used in the body of the ST if the ST author chooses to
                    use key derivation in the key chaining approach that is specified in FCS_KYC_EXT.2.</h:p>
                  <h:p>This requirement establishes acceptable methods for generating a new random key or an existing submask to create a new key along the key chain.</h:p>

                </note>
                <aactivity>
                  <TSS>The evaluator shall verify the TSS includes a description of the key derivation function
                    and shall verify the key derivation uses an approved derivation mode and key expansion
                    algorithm according to SP 800-108 and SP 800-132.</TSS>
                  <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
                  <CustomEA name="KMD">The evaluator shall examine the vendor’s KMD to ensure that all keys used are derived
                    using an approved method and a description of how and when the keys are derived.</CustomEA>
                  <Tests>There are no test evaluation activities for this SFR.</Tests>
                </aactivity>
              </f-element>
            
            </f-component>
        
            <f-component cc-id="fcs_kyc_ext.1" name="Key Chaining (Initiator)" id="fcs-kyc-ext-1" status="invisible">
              <consistency-rationale/>
              <comp-lev>requires the TSF to maintain a key chain for a BEV that is provided to a component external to the TOE.
                Note that this cPP does not include FCS_KYC_EXT.1; it is only included here to provide a complete definition of the FCS_KYC_EXT family.
              </comp-lev>
              <management/>
              <audit/>
              <dependencies>
                FCS_CKM.1 Cryptographic Key Generation
                </dependencies>
              <f-element id="fcs-kyc-ext-1-1">
                <title>
                  The TSF shall maintain a key chain of: 
                    <selectables linebreak="yes">
                      <selectable>one, using a submask as the BEV;</selectable>
                      <selectable>intermediate keys originating from one or more submasks to the BEV using the following methods:
                        <selectables linebreak="yes">
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-1">key encryption as specified in FCS_COP.1<h:b>/KeyEnc</h:b></selectable>
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-2">key transport as specified in FCS_COP.1<h:b>/KeyEncap</h:b>,</selectable>
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-3">key wrapping as specified in FCS_COP.1<h:b>/KeyWrap</h:b>,</selectable>
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-4">key derivation as specified in FCS_KDF_EXT.1</selectable>                          
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-5">key combining as specified in FCS_SMC_EXT.1,</selectable>
                          
                          
                      </selectables></selectable></selectables>
                  while maintaining an effective strength of 
                    <selectables>
                      <selectable>128 bits</selectable>
                      <selectable>256 bits</selectable>
                    </selectables> for symmetric keys and an effective strength of 
                      <selectables>
                      <selectable>not applicable</selectable>
                      <selectable>112 bits</selectable>
                      <selectable>128 bits</selectable>
                      <selectable>192 bits</selectable>
                      <selectable>256 bits</selectable>
                  </selectables> for asymmetric keys.
                </title>
                
                <ext-comp-def-title>
                  <title>The TSF shall maintain a key chain of: 
                    <selectables linebreak="yes">
                      <selectable>one, using a submask as the BEV;</selectable>
                      <selectable>intermediate keys originating from one or more submasks to the BEV using the following methods:
                        <selectables linebreak="yes">
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-1">key encryption as specified in FCS_COP.1</selectable>
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-2">key transport as specified in FCS_COP.1,</selectable>
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-3">key wrapping as specified in FCS_COP.1,</selectable>
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-4">key derivation as specified in FCS_KDF_EXT.1</selectable>                          
                          <selectable id="sel-fcs-kyc-ext-1-1-sel-5">key combining as specified in FCS_SMC_EXT.1,</selectable>
                          
                          
                        </selectables></selectable></selectables>
                    while maintaining an effective strength of 
                    <selectables>
                      <selectable>128 bits</selectable>
                      <selectable>256 bits</selectable>
                    </selectables> for symmetric keys and an effective strength of 
                    <selectables>
                      <selectable>not applicable</selectable>
                      <selectable>112 bits</selectable>
                      <selectable>128 bits</selectable>
                      <selectable>192 bits</selectable>
                      <selectable>256 bits</selectable>
                    </selectables> for asymmetric keys.</title>
                </ext-comp-def-title>                                  
              </f-element>
              
              <f-element id="fcs-kyc-ext-1-2">
                <title>
                  The TSF shall provide at least a 
                    <selectables>
                      <selectable id="fcs-kyc-ext-1-2-sel-1a">128 bits</selectable>
                      <selectable id="fcs-kyc-ext-1-2-sel-1b">256 bits</selectable>
                    </selectables> BEV to <assignable>one or more external entities</assignable>
                    <selectables linebreak='yes'>
                      <selectable id="fcs-kyc-ext-1-2-sel-2a">after the TSF has successfully performed the validation process as specified in FCS_VAL_EXT.1</selectable>
                      <selectable id="fcs-kyc-ext-1-2-sel-2b">without validation taking place</selectable>
                  </selectables> 
                </title>
                <note role="application">
                  Key Chaining is the method of using multiple layers of encryption keys to ultimately secure the BEV. The number of intermediate keys will vary – from one 
                  (e.g., taking the conditioned password authorization factor and directly using it as the BEV) to many. This applies to all keys that contribute to the 
                  ultimate wrapping or derivation of the BEV; including those in areas of protected storage (e.g. TPM stored keys, comparison values).<h:br/><h:br/>
                  
                  Multiple key chains to the BEV are allowed, as long as all chains meet the key chain requirement.<h:br/><h:br/>
                  
                  The BEV is considered to be equivalent to keying material and therefore additional checksums or similar values are not the BEV, even if they are sent with
                  the BEV.<h:br/><h:br/> 
                
                  Once the ST author has selected a method to create the chain (either by deriving keys or unwrapping them or encrypting keys or using RSA Key Transport), they
                  pull the appropriate requirement out of Appendix B. It is allowable for an implementation to use any or all methods.<h:br/><h:br/>
                  
                  For FCS_KYC_EXT.1.2, the validation process is defined in FCS_VAL_EXT.1, Appendix B. If that selection is made by the ST author, then FCS_VAL_EXT.1 is included
                  in the body of the ST.
                  
                  The method the TOE uses to chain keys and manage/protect them is described in the Key Management Description; see Appendix E for more information.<h:br/><h:br/>
                
                  The TOE’s use of key encryption, key encapsulation, key wrapping, key derivation, or submask combining determines whether the selection-based requirements 
                  FCS_COP.1/KeyEnc, FCS_COP.1/KeyEncap, FCS_COP.1/KeyWrap, FCS_KDF_EXT.1, and FCS_SMC_EXT.1 are claimed. Additionally, the TOE’s use of key encryption or key
                  wrapping for key chaining requires FCS_CKM.1/SKG and FCS_RBG.1 (for key generation) and FCS_COP.1/SKC (for symmetric encryption) to be claimed.
                  
                </note>
                  <aactivity >
                      <TSS>The evaluator shall verify the TSS contains a high-level description of the BEV sizes– that it supports BEV outputs of no fewer 128 bits for products that support only AES128, and no fewer than 256 bits for products that support AES-256.</TSS>
                      <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
                      <CustomEA name="KMD">
                        <h:p>The evaluator shall examine the KMD describes a high level description of the key hierarchy for all authorizations methods selected in FCS_AFA_EXT.1 that are used to protect the BEV. The evaluator shall examine the KMD to ensure it describes the key chain in detail. The description of the key chain shall be reviewed to ensure it maintains a chain of keys using key wrap or key derivation methods that meet FCS_COP.1/KeyWrap and FCS_KDF_EXT.1.</h:p>
                        <h:p>The evaluator shall examine the KMD to ensure that it describes how the key chain
                          process functions, such that it does not expose any material that might compromise any
                          key in the chain. (e.g. using a key directly as a compare value against a TPM) This
                          description must include a diagram illustrating the key hierarchy implemented and
                          detail where all keys and keying material is stored or what it is derived from. The
                          evaluator shall examine the key hierarchy to ensure that at no point the chain could be
                          broken without a cryptographic exhaust or the initial authorization value and the
                          effective strength of the BEV is maintained throughout the key chain.</h:p>
                        <h:p>The evaluator shall verify the KMD includes a description of the strength of keys
                          throughout the key chain.</h:p></CustomEA>                       
                      <Tests>There are no test evaluation activities for this SFR.</Tests>
                  </aactivity>
              </f-element>
          
            </f-component>
        
        <f-component cc-id="fcs_kyc_ext.2" name="Key Chaining (Recipient) " id="fcs-kyc-ext-2">
          <consistency-rationale/>
          <comp-lev>requires the TSF to be able to accept a BEV that is then chained to a DEK used
            by the TSF through some method. <h:br/><h:br/>
            </comp-lev>
          <management/>
          <audit/>
          <dependencies>No dependencies</dependencies>
          <f-element id="fcs-kyc-ext-2-1">
            <title>The TSF shall accept a BEV of at least <selectables><selectable>128 bits</selectable><selectable>256 bits</selectable></selectables> from <assignable>one or more external entities</assignable>.</title>
            
          </f-element>
          <f-element id="fcs-kyc-ext-2-2">
            <title>
              The TSF shall maintain a chain of intermediary keys originating from the BEV to the DEK using the following methods: <selectables linebreak="yes">
                <selectable>asymmetric key generation as specified in FCS_CKM.1<h:b>/AKG</h:b></selectable>
                <selectable id="fcs-kyc-ext-2-2-sel-2">symmetric key generation as specified in FCS_CKM.1<h:b>/SKG</h:b></selectable>
                <selectable>key derivation as specified in FCS_KDF_EXT.1</selectable>
                <selectable>key wrapping as specified in FCS_COP.1<h:b>/KeyWrap</h:b></selectable>
                <selectable>key transport as specified in FCS_COP.1<h:b>/KeyEncap</h:b></selectable>
                <selectable id="fcs-kyc-ext-2-2-sel-1">key encryption as specified in FCS_COP.1<h:b>/KeyEnc</h:b></selectable>
              </selectables> while maintaining an effective strength of <selectables>
                <selectable>128 bits</selectable>
                <selectable>256 bits</selectable>
              </selectables>
              while maintaining an effective strength of <selectables><selectable>128 bits</selectable>
                <selectable>256 bits</selectable></selectables> for symmetric keys and an effective strength of <selectables><selectable>not applicable</selectable><selectable>112 bits</selectable><selectable>128 bits</selectable><selectable>192 bits</selectable><selectable>256 bits</selectable></selectables> for asymmetric keys.
            </title>
            
            <ext-comp-def-title>
              <title>
                The TSF shall maintain a chain of intermediary keys originating from the BEV to the DEK using the following methods: <selectables linebreak="yes">
                  <selectable>asymmetric key generation as specified in FCS_CKM.1</selectable>
                  <selectable id="fcs-kyc-ext-2-2-sel-2">symmetric key generation as specified in FCS_CKM.1</selectable>
                  <selectable>key derivation as specified in FCS_KDF_EXT.1</selectable>
                  <selectable>key wrapping as specified in FCS_COP.1</selectable>
                  <selectable>key transport as specified in FCS_COP.1</selectable>
                  <selectable>key encryption as specified in FCS_COP.1</selectable>
                </selectables> while maintaining an effective strength of <selectables>
                  <selectable>128 bits</selectable>
                  <selectable>256 bits</selectable>
                </selectables>
                while maintaining an effective strength of <selectables><selectable>128 bits</selectable>
                  <selectable>256 bits</selectable></selectables> for symmetric keys and an effective strength of <selectables><selectable>not applicable</selectable><selectable>112 bits</selectable><selectable>128 bits</selectable><selectable>192 bits</selectable><selectable>256 bits</selectable></selectables> for asymmetric keys.
              </title>
            </ext-comp-def-title>
            <note role="application">
              Key Chaining is the method of using multiple layers of encryption keys to
              ultimately secure the protected data encrypted on the drive. The number of intermediate keys
              will vary – from two (e.g., using the BEV as an intermediary key to wrap the DEK) to many.
              This applies to all keys that contribute to the ultimate wrapping or derivation of the DEK;
              including those in areas of protected storage (e.g. TPM stored keys, comparison values).<h:br/><h:br/>
              
              The BEV is considered to be equivalent to keying material and therefore additional checksums
              or similar values are not the BEV, even if they are sent with the BEV.<h:br/><h:br/>
              
              Once the ST author has selected a method to create the chain (either by deriving keys or
              unwrapping them), they pull the appropriate requirement out of Appendix B. It is allowable for
              an implementation to use both methods.<h:br/><h:br/>
              
              The method the TOE uses to chain keys and manage/protect them is described in the Key
              Management Description; see Appendix E for more information.  
            </note>
            <aactivity>
              <TSS/>
              <Guidance/>
              <KMD>
                The evaluator shall examine the KMD to ensure it describes a high level key hierarchy and details of the key chain.
                The description of the key chain shall be reviewed to ensure it maintains a chain of keys using key wrap or key 
                derivation methods that meet FCS_KDF_EXT.1, FCS_COP.1(d), FCS_COP.1(e), and/or FCS_COP.1(g).<h:br/><h:br/>
                
                The evaluator shall examine the KMD to ensure that it describes how the key chain process functions, such that it 
                does not expose any material that might compromise any key in the chain. (e.g. using a key directly as a compare 
                value against a TPM) This description must include a diagram illustrating the key hierarchy implemented and detail
                where all keys and keying material is stored or what it is derived from. The evaluator shall examine the key 
                hierarchy to ensure that at no point the chain could be broken without a cryptographic exhaust or knowledge 
                of the BEV and the effective strength of the DEK is maintained throughout the Key Chain.<h:br/><h:br/>
                
                The evaluator shall verify the KMD includes a description of the strength of keys throughout the key chain.
              </KMD>
              <Tests/>
            </aactivity>
          </f-element>
          
        </f-component>

        
            <f-component cc-id="fcs_rbg.1" name="Cryptographic Operation (Random Bit Generation)"
              id="fcs-rbg-1" status="sel-based">
              <depends on-sel="sel-fcs-afa-ext-1-1-sel-1b"/>
              <depends on-sel="sel-fcs-afa-ext-1-1-sel-6a"/>
              <depends on-sel="sel-fcs-sni-ext-1-1-sel-2"/>
              <depends on-sel="sel-fcs-kdf-ext-1-1-sel-1a"/>
              
              <f-element id="fcs-rbg-1-1">
                <title>
                  The TSF shall perform deterministic random bit generation services using
                  <selectables>
                    <selectable><h:i>Hash_DRBG (any)</h:i></selectable>
                    <selectable><h:i>HMAC_DRBG (any)</h:i></selectable>
                    <selectable><h:i>CTR_DRBG (AES)</h:i></selectable>
                  </selectables> in accordance with <selectables>
                    <selectable><h:i>ISO/IEC 18031:2011</h:i></selectable>
                    <selectable id='fcs-rbg-1-1-nist'><h:i>NIST SP 800-90A</h:i></selectable>
                  </selectables> after initialization with a seed.
                </title> 
                
                <aactivity level="element">
                  <TSS>The evaluator shall verify that the TSS identifies the DRBGs used by the TOE.</TSS>
                  <Guidance>If the DRBG functionality is configurable, the evaluator shall verify that the operational guidance includes instructions on how to configure this behavior.</Guidance>
                  <Tests>
                    <h:p>
                      The evaluator shall perform the following tests:
                    </h:p><h:p>
                      The evaluator shall perform 15 trials for the DRBG implementation. If the DRBG
                      is configurable, the evaluator shall perform 15 trials for each configuration. The
                      evaluator shall also confirm that the operational guidance contains appropriate
                      instructions for configuring the DRBG functionality.
                    </h:p><h:p>
                      If the DRBG has  prediction resistance enabled, each trial consists of (1) instantiate DRBG, (2)
                      generate the first block of random bits (3) generate a second block of random bits
                      (4) uninstantiate. The evaluator verifies that the second block of random bits is
                      the expected value. The evaluator shall generate eight input values for each
                      trial. The first is a count (0 – 14). The next three are entropy input, nonce, and
                      personalization string for the instantiate operation. The next two are additional
                      input and entropy input for the first call to generate. The final two are
                      additional input and entropy input for the second call to generate. These values
                      are randomly generated. "generate one block of random bits" means to generate
                      random bits with number of returned bits equal to the Output Block Length (as
                      defined in NIST SP 800-90A).
                    </h:p><h:p>
                      If the DRBG does not have prediction resistance,
                      each trial consists of (1) instantiate DRBG, (2) generate the first block of
                      random bits (3) reseed, (4) generate a second block of random bits (5)
                      uninstantiate. The evaluator verifies that the second block of random bits is the
                      expected value. The evaluator shall generate eight input values for each trial.
                      The first is a count (0 – 14). The next three are entropy input, nonce, and
                      personalization string for the instantiate operation. The fifth value is
                      additional input to the first call to generate. The sixth and seventh are
                      additional input and entropy input to the call to reseed. The final value is
                      additional input to the second generate call.
                    </h:p><h:p>
                      The following list contains more information on some of the input values to be generated/selected by the evaluator.
                      <h:ul>
                        <h:li> <h:b>Entropy input:</h:b> The length of the entropy input value must equal the seed
                          length.</h:li>                        
                        <h:li><h:b>Nonce:</h:b> If a nonce is supported (CTR_DRBG with no Derivation Function does
                          not use a nonce), the nonce bit length is one-half the seed length. </h:li>
                        <h:li><h:b>Personalization string:</h:b> The length of the personalization string must be
                          less than or equal to seed length. If the implementation only supports one
                          personalization string length, then the same length can be used for both values.
                          If more than one string length is support, the evaluator shall use personalization
                          strings of two different lengths. If the implementation does not use a
                          personalization string, no value needs to be supplied. </h:li>
                        <h:li><h:b>Additional input:</h:b> The additional input bit lengths have the same defaults
                          and restrictions as the personalization string lengths.</h:li>
                      </h:ul>
                    </h:p>
                  </Tests>
                </aactivity>  
              </f-element>
              
              <f-element id="fcs-rbg-1-2">
                <title>
                  The TSF shall use a <selectables>
                    <selectable id="internal-seed">TSF noise source <assignable>name of noise source</assignable></selectable>
                    <selectable id="internal-seeds"><h:b>multiple TSF noise sources <assignable>names of noise sources</assignable></h:b></selectable>
                    <selectable id="external-seed">TSF interface for seeding</selectable>
                  </selectables>
                  for initialized seeding.
                </title>
                <note role="application">
                  <h:p>
                    For the 
                    selection in this requirement, the ST author selects "TSF noise source" if
                    a single noise source is used as input to the DRBG. The ST author selects "multiple TSF noise sources" if a seed is formed from a combination of two or more noise sources within the TOE boundary. If the TSF implements two or more separate DRBGs that are seeded in separate manners, this SFR should be iterated for each DRBG. It multiple distinct noise sources exist such that each DRBG only uses one of them, then each iteration would select "TSF noise source"; "multiple TSF noise sources" is only selected if a single DRBG uses multiple noise sources for its seed. The ST author selects "TSF interface for seeding" if noise source data is generated outside the TOE boundary.
                  </h:p>
                  <h:p>
                    If "TSF noise source" is selected, FCS_RBG.3 must be claimed.
                  </h:p>
                  <h:p>
                    If "multiple TSF noise sources" is selected, FCS_RBG.4 and FCS_RBG.5 must be claimed. 
                  </h:p>
                  <h:p>
                    If "TSF interface for seeding" is selected, FCS_RBG.2 must be claimed. 
                  </h:p>
                </note>
                <aactivity level="element">
                  <h:p>
                    Documentation will be produced - and the evaluator shall perform the
                    activities - in accordance with Appendix D, "Entropy Documentation and
                    Assessment" and the <h:a href="https://niap-ccevs.org/Documents_and_Guidance/ccevs/Entropy%20Documentation%20and%20Assessment%20Clarification.pdf">,
                      Clarification to the Entropy Documentation and Assessment Annex</h:a>.
                  </h:p>
                  <TSS/>
                  <Guidance/>
                  <Tests/>
                  
                </aactivity>
              </f-element>
              
              <f-element id="fcs-rbg-1-3">
                <title>
                  The TSF shall update the RBG state by <selectables>
                    <selectable>reseeding</selectable>
                    <selectable>uninstantiating and reinstantiating</selectable>
                  </selectables> using a <selectables>
                    <selectable>TSF noise source <assignable>name of noise source</assignable></selectable>
                    <selectable>TSF interface for seeding</selectable></selectables>
                  in the following situations: <selectables linebreak="yes">
                    <selectable>never</selectable>
                    <selectable>on demand</selectable>
                    <selectable>on the condition: <assignable>condition</assignable></selectable>
                    <selectable>after <assignable>time</assignable></selectable>
                  </selectables>
                  in accordance with <assignable>list of standards</assignable>.
                </title>
                <note role="application">
                  This SFR is claimed when the TSF requires the use of random bit generation for submask generation (FCS_AFA_EXT.1,
                  FCS_KDF_EXT.1) or salt generation (FCS_SNI_EXT.1).
                </note>
                <aactivity level="element">              
                  <TSS>
                    The evaluator shall verify that the TSS identifies how the DRBG state is updated, and the situations under which this may occur.
                  </TSS>
                  <Guidance>If the ST claims that the DRBG state can be updated on demand, the evaluator shall verify that the operational guidance has instructions for how to perform this operation.</Guidance>
                  <Tests/>
                </aactivity>
              </f-element>
                        
            </f-component>
        
        <f-component cc-id="fcs_rbg.2" name="Random Bit Generation (External Seeding)"  status="sel-based">
              <depends on-sel="external-seed"></depends>
              <f-element id="fcs-rbg-2-1">
                <title>
                  The TSF shall be able to accept a minimum input of <assignable>minimum input length greater than zero</assignable> from a TSF interface for the purpose of seeding.
                </title>
                <note role="application">
                  This requirement is claimed when a DRBG is seeded with entropy from one or more noise source that is outside the TOE
                  boundary. Typically the entropy produced by an environmental noise source is conditioned such that the input length has
                  full entropy and is therefore  usable as the seed. However, if this is not the case, it should be noted what the minimum
                  entropy rate of the noise source is so that the TSF can collect a sufficiently large sample of noise data to be
                  conditioned into a seed value.
                </note>
                <aactivity>
                  <h:p>
                    The evaluator shall examine the entropy documentation required by FCS_RBG.1.2 to verify that it identifies, for each DRBG function implemented by the TOE, the TSF external interface used to seed the TOE's DRBG. The evaluator shall verify that this includes the amount of sampled data and the min-entropy rate of the sampled data such that it can be determined that sufficient entropy can be made available for the highest strength keys that the TSF can generate (e.g., 256 bits). If the seed data cannot be assumed to have full entropy (e.g., the min-entropy of the sampled bits is less than 1), the evaluator shall ensure that the entropy documentation describes the method by which the TOE estimates the amount of entropy that has been accumulated to ensure that sufficient data is collected and any conditioning that the TSF applies to the output data to create a seed of sufficient size with full entropy.
                  </h:p>
                  <TSS/>
                  <Guidance/>
                  <Tests/>
                </aactivity>
              </f-element>
                        
            </f-component>
        
        <f-component cc-id="fcs_rbg.3" name="Random Bit Generation (Internal Seeding - Single Source)" status="sel-based">
          <depends on-sel="internal-seed"/>    
          <f-element id="fcs-rbg-3-1">
                <title>
                  The TSF shall be able to seed the RBG using a <selectables choose-one-of="yes">
                    <selectable>TSF software-based noise source</selectable>
                    <selectable>TSF hardware-based noise source</selectable>
                  </selectables> <assignable>name of noise source</assignable> with a minimum of <assignable>number of bits</assignable> bits of min-entropy.
                </title>
                <note role="application">This requirement is claimed when a DRBG is seeded with entropy from a single noise source that is within the TOE boundary. Min-entropy should be expressed as a ratio of entropy bits to sampled bits so that the total amount of data needed to ensure full entropy is known, as well as the conditioning function by which that data is reduced in size to the seed.</note>
                
                <aactivity>
                  <h:p>
                    The evaluator shall examine the entropy documentation required by FCS_RBG.1.2 to verify that it identifies, for each DRBG function implemented by the TOE, the TSF noise source used to seed the TOE's DRBG. The evaluator shall verify that this includes the amount of sampled data and the min-entropy rate of the sampled data such that it can be determined that sufficient entropy can be made available for the highest strength keys that the TSF can generate (e.g., 256 bits). If the seed data cannot be assumed to have full entropy (e.g., the min-entropy of the sampled bits is less than 1), the evaluator shall ensure that the entropy documentation describes the method by which the TOE estimates the amount of entropy that has been accumulated to ensure that sufficient data is collected and any conditioning that the TSF applies to the output data to create a seed of sufficient size with full entropy.
                  </h:p>
                  <TSS/>
                  <Guidance/>
                  <Tests/>
                </aactivity>                  
              </f-element>
          
            </f-component>
        
        <f-component cc-id="fcs_rbg.4" name="Random Bit Generation (Internal Seeding - Multiple Sources)" status="sel-based">
          <depends on-sel="internal-seeds"/>    
          <f-element id="fcs-rbg-4-1">
                <title>
                  The TSF shall be able to seed the RBG using <selectables><selectable><assignable>number</assignable> TSF software-based noise sources</selectable><selectable><assignable> number</assignable> TSF hardware-based noise sources</selectable></selectables>.
                </title>
                <note role="application">
                  This requirement is claimed when a DRBG is seeded with entropy from multiple noise sources that are within the TOE boundary. 
                  FCS_RBG.5 defines the mechanism by which these sources are combined to ensure sufficient minimum entropy.
                </note>
                <aactivity>
                  <h:p>
                    The evaluator shall examine the entropy documentation required by FCS_RBG.1.2 to verify that it identifies, for each DRBG function implemented by the TOE, each TSF noise source used to seed the TOE's DRBG. The evaluator shall verify that this includes the amount of sampled data and the min-entropy rate of the sampled data from each data source.
                  </h:p>
                  <TSS/>
                  <Guidance/>
                  <Tests/>
                </aactivity>
              </f-element>
         
            </f-component>
        
        <f-component cc-id="fcs_rbg.5" name="Random Bit Generation (Combining Noise Sources)" status="sel-based">
          <depends on-sel="internal-seeds"/>    
          <f-element id="fcs-rbg-5-1">
                <title>
                  The TSF shall <assignable> combining operation</assignable> <selectables><selectable>output from TSF noise sources</selectable><selectable> input from TSF interfaces for seeding)</selectable></selectables> to create the entropy input into the derivation function as defined in <assignable> list of standards</assignable>, resulting in a minimum of <assignable> number of bits</assignable> bits of min-entropy.

                </title>
                <note role="application">
                  Examples of typical combining operations include, but are not limited to, XORing or hashing.
                </note>
                <aactivity>
                  <h:p>
                    Using the entropy sources specified in FCS_RBG.4, the evaluator shall examine the entropy documentation required by FCS_RBG.1.2 to verify that it describes the method by which the various entropy sources are combined into a single seed. This should include an estimation of the rate at which each noise source outputs data and whether this is dependent on any system-specific factors so that each source's relative contribution to the overall entropy is understood. The evaluator shall verify that the resulting combination of sampled data and the min-entropy rate of the sampled data is described in sufficient detail to determine that sufficient entropy can be made available for the highest strength keys that the TSF can generate (e.g., 256 bits). If the seed data cannot be assumed to have full entropy (e.g., the min-entropy of the sampled bits is less than 1), the evaluator shall ensure that the entropy documentation describes the method by which the TOE estimates the amount of entropy that has been accumulated to ensure that sufficient data is collected and any conditioning that the TSF applies to the output data to create a seed of sufficient size with full entropy.
                  </h:p>
                  <TSS/>
                  <Guidance/>
                  <Tests/>
                </aactivity>
              </f-element>
          
            </f-component>
        
            <f-component cc-id="fcs_smc_ext.1" name="Submask Combining " id="fcs-smc-ext-1" status="sel-based">
              <depends on-sel="sel-fcs-kyc-ext-1-1-sel-5"/>
              <depends on-sel="sel-fpt-kyp-ext-1-1-sel-3c"></depends>
              <consistency-rationale/>
              <comp-lev>requires the TSF to combine the submasks in a predictable fashion.</comp-lev>
              <management/>
              <audit/>
              <dependencies>FCS_COP.1 Cryptographic Operation</dependencies>
              <f-element id="fcs-smc-ext-1-1">
                <title>
                  The TSF shall combine submasks using the following method <selectables><selectable>exclusive OR (XOR)</selectable><selectable>SHA-256</selectable><selectable>SHA-384</selectable><selectable>SHA-521</selectable></selectables> to generate an [<h:i>intermediary key or BEV</h:i>].
                </title>
                <ext-comp-def-title>
                  <title>The TSF shall combine submasks using the following method <selectables>
                    <selectable>exclusive OR (XOR)</selectable>
                    <selectable>SHA-256</selectable>
                    <selectable>SHA-384</selectable>
                    <selectable>SHA-521</selectable>
                  </selectables> to generate an <assignable>types of keys</assignable>.</title>
                </ext-comp-def-title>
                <note role="application">
                  This requirement specifies the way that a product may combine the various submasks by using either an XOR or an 
                  approved SHA-hash. The approved hash functions are captured in
                  FCS_COP.1/Hash.<h:br/><h:br/>
                  
                  This SFR is claimed when the TSF requires the use of submask combining as part of maintaining or deriving a key chain.
                </note>
                  <aactivity>
                    <TSS>If the submasks produced from the authorization factors are XORed together to form
                      the BEV or intermediate key, the TSS section shall identify how this is performed (e.g.,
                      if there are ordering requirements, checks performed, etc.). The evaluator shall also
                      confirm that the TSS describes how the length of the output produced is at least the
                      same as that of the BEV.</TSS>
                      <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
                      <CustomEA name="KMD">The evaluator shall review the KMD to ensure that an approved combination is used
                        and does not result in the weakening or exposure of key material.</CustomEA>
                      <Tests>The evaluator shall perform the following test:<testlist>
                        <test>(conditional): If there is more than one authorization factor, ensure that failure
                          to supply a required authorization factor does not result in access to the encrypted data.</test>
                      </testlist></Tests>
                  </aactivity>
              </f-element>
              
            </f-component>
        
            <f-component cc-id="fcs_sni_ext.1" name="Cryptographic Operation (Salt, Nonce, and Initialization Vector Generation)" id="fcs_sni_ext.1">
              <consistency-rationale/>
              <comp-lev>requires the generation of salts, nonces, and IVs to be used by the cryptographic components of the TOE to be performed in the specified manner. </comp-lev>
              <management/>
              <audit/>
              <dependencies>FCS_RBG.1 Cryptographic Operation (Random Bit Generation)</dependencies>
              <f-element id="fcs-sni-ext-1-1">
                <title>
                  The TSF shall <selectables>
                    <selectable id="sel-fcs-sni-ext-1-1-sel-1">use no salts</selectable>
                    <selectable>use salts that are generated by a 
                      <selectables>
                        <selectable id="sel-fcs-sni-ext-1-1-sel-2"> DRBG as specified in FCS_RBG.1</selectable>
                        <selectable id="sel-fcs-sni-ext-1-1-sel-3"> DRBG provided by the host platform</selectable>
                      </selectables>
                    </selectable>
                  </selectables>.
                </title>
                  
              </f-element>
              <f-element id="fcs-sni-ext-1-2">
                <title>The TSF shall use 
                  <selectables>
                    <selectable id="sel-fcs-sni-ext-1-2-sel-1">no nonces</selectable>
                    <selectable id="sel-fcs-sni-ext-1-2-sel-2">unique nonces with a minimum size of [<h:i>64</h:i>] bits</selectable>
                  </selectables>.</title>
                
              <ext-comp-def-title>
                <title>The TSF shall use 
                  <selectables>
                    <selectable>no nonces</selectable>
                    <selectable>unique nonces with a minimum size of <assignable>number of bits</assignable> bits</selectable>
                  </selectables>.</title>
              </ext-comp-def-title>
                
              </f-element>
              
              <f-element id="fcs-sni-ext-1-3">
                <title>The TSF shall 
                  <selectables>
                    <selectable id="sel-fcs-sni-ext-1-3-sel-1">use no IVs</selectable>
                    <selectable id="sel-fcs-sni-ext-1-3-sel-2">create IVs in the following manner <selectables linebreak='yes'>
                      <selectable id="sel-fcs-sni-ext-1-3-sel-2a">CBC: IVs shall be non-repeating and unpredictable</selectable>
                      <selectable id="sel-fcs-sni-ext-1-3-sel-3b">CCM: Nonce shall be non-repeating and unpredictable</selectable>
                      <selectable id="sel-fcs-sni-ext-1-3-sel-4c">XTS: No IV. Tweak values shall be non-negative integers, assigned consecutively, and starting at an arbitrary non-negative integer;</selectable>
                      <selectable> id="sel-fcs-sni-ext-1-1-sel-2"GCM: IV shall be non-repeating. The number of invocations of GCM shall not exceed 2^32 for a given secret key</selectable>
                    </selectables>
                  </selectable>
                </selectables>.</title>
                <note role="application">
                  This requirement covers several important factors – the salt must be random, but the nonces only have to be unique. FCS_SNI_EXT.1.3 specifies how the IV should
                  be handled for each encryption mode. CBC, XTS, and GCM are allowed for AES encryption of the data. AES-CCM is an allowed mode for Key Wrapping.<h:br/><h:br/>
                  
                  If the TSF uses salts in support of cryptographic operations, and these salts are generated by the TSF, then FCS_CKM.1/SKG and FCS_RBG.1 must be claimed.
                
                </note>
                <aactivity>
                    <TSS>
                      <h:p>If salts are used, the evaluator shall ensure the TSS describes how salts are generated. The evaluator shall confirm that the salt is generating using an RBG described in FCS_RBG.1 or by the Operational Environment. If external function is used for this purpose, the TSS should include the specific API that is called with inputs.</h:p>
                      <h:p>If IVs or nonces are used, the evaluator shall ensure the TSS describes how nonces are created uniquely and how IVs and tweaks are handled (based on the AES mode). The evaluator shall confirm that the nonces are unique and the IVs and tweaks meet the stated requirements.</h:p></TSS>
                    <Guidance/>
                    <KMD/>
                    <Tests/>
                </aactivity>
              </f-element>
             
            </f-component>
        
            <f-component cc-id="fcs_val_ext.1" name="Validation " id="fcs-val-ext-1" status="sel-based">
              <depends on-sel="fcs-kyc-ext-1-2-sel-2a"/>
              <consistency-rationale/>
              <comp-lev>requires the TSF to validate submasks and BEVs by one or more of the specified methods.</comp-lev>
              <management/>
              <audit/>
              <dependencies>
                <h:p>FCS_COP.1 Cryptographic Operation</h:p>                
              </dependencies>
              <f-element id="fcs-val-ext-1-1">
                <title>
                  The TSF shall perform validation of the <selectables>
                    <selectable id="sel-fcs-val-ext-1-1-sel-1a">submask</selectable>
                    <selectable id="sel-fcs-val-ext-1-1-sel-1b">intermediate key</selectable>
                    <selectable id="sel-fcs-val-ext-1-1-sel-1c">BEV</selectable>
                  </selectables>
                  using the following methods: <selectables linebreak="yes">
                    <selectable id="sel-fcs-val-ext-1-1-sel-2a">key wrap as specified in FCS_COP.1<h:b>/KeyWrap</h:b>;</selectable>
                    <selectable id="sel-fcs-val-ext-1-1-sel-2a">hash the <selectables>
                      <selectable>submask</selectable>
                      <selectable>intermediate key</selectable>
                      <selectable>BEV</selectable>
                    </selectables>
                    as specified in <selectables>
                      <selectable id="fcs-val-ext-1-1-hash">FCS_COP.1<h:b>/Hash</h:b></selectable>
                      <selectable id="fcs-val-ext-1-1-keyhash">FCS_COP.1<h:b>/KeyedHash</h:b></selectable>
                    </selectables> and compare it to a stored hashed <selectables><selectable>submask</selectable><selectable> intermediate key</selectable><selectable>BEV</selectable></selectables>;</selectable>
                    <selectable id="fcs-val-ext-1-1-decr">decrypt a known value using the <selectables><selectable>submask</selectable><selectable>intermediate key</selectable><selectable>BEV</selectable></selectables> specified in FCS_COP.1<h:b>/SKC</h:b> and compare it against a stored known value </selectable>
                  </selectables>.
                </title>
                
                <ext-comp-def-title>
                  <title>
                    The TSF shall perform validation of the <selectables>
                      <selectable>submask</selectable>
                      <selectable>intermediate key</selectable>
                      <selectable>BEV</selectable>
                    </selectables>
                    using the following methods: <selectables linebreak="yes">
                      <selectable>key wrap as specified in FCS_COP.1;</selectable>
                      <selectable>hash the <selectables>
                        <selectable>submask</selectable>
                        <selectable>intermediate key</selectable>
                        <selectable>BEV</selectable>
                      </selectables>
                        as specified in <assignable>cryptographic operation requirement</assignable> and compare it to a stored hashed <selectables><selectable>submask</selectable><selectable> intermediate key</selectable><selectable>BEV</selectable></selectables>;</selectable>
                      <selectable id="fcs-val-ext-1-1-decr">decrypt a known value using the <selectables><selectable>submask</selectable><selectable>intermediate key</selectable><selectable>BEV</selectable></selectables> specified in FCS_COP.1 and compare it against a stored known value </selectable>
                    </selectables>.
                  </title>
                </ext-comp-def-title>
                
                  <aactivity level="element">
                      <TSS>
                        <h:p>The evaluator shall examine the TSS to determine which authorization factors support
                          validation.</h:p>
                        <h:p>The evaluator shall examine the TSS to review a high-level description if multiple
                          submasks are used within the TOE, how the submasks are validated (e.g., each submask
                          validated before combining, once combined validation takes place).</h:p></TSS>
                      <Guidance>
                        <h:p>(conditional) If the validation functionality is configurable, the evaluator shall examine
                          the operational guidance to ensure it describes how to configure the TOE to ensure the
                          limits regarding validation attempts can be established.</h:p>
                        <h:p>(conditional) If the validation functionality is specified by the ST author, the evaluator
                          shall examine the operational guidance to ensure that it states the values that the TOE
                          uses for limits regarding validation attempts.</h:p></Guidance>
                      <CustomEA name="KMD">
                        <h:p>The evaluator shall examine the KMD to verify that it described the method the TOE
                          employs to limit the number of consecutively failed authorization attempts.</h:p>
                        <h:p>The evaluator shall examine the vendor’s KMD to ensure it describes how validation
                          is performed. The description of the validation process in the KMD provides detailed
                          information how the TOE validates the submasks. The KMD describes how the process
                          works, such that it does not expose any material that might compromise the submasks.</h:p></CustomEA>
                      <Tests>
                        The evaluator shall perform the following tests:
                        <testlist>
                          <test>The evaluator shall determine the limit on the average rate of the number of
                            consecutive failed authorization attempts. The evaluator will test the TOE by entering
                            that number of incorrect authorization factors in consecutive attempts to access the
                            protected data. If the limit mechanism includes any “lockout” period, the time period
                            tested should include at least one such period. Then the evaluator will verify that the
                            TOE behaves as described in the TSS.</test>
                          <test>For each validated authorization factor, ensure that when the user provides an
                            incorrect authorization factor, the TOE prevents the BEV from being forwarded outside
                            the TOE (e.g., to the EE).</test>
                        </testlist></Tests>
                  </aactivity>
              </f-element>
              <f-element id="fcs-val-ext-1-2">
                <title>
                  The TSF shall require validation of the [<h:i>BEV</h:i>] prior to [<h:i>forwarding the BEV to the EE</h:i>].
                </title>
                
                <ext-comp-def-title>
                  <title>The TSF shall require validation of the <selectables>
                    <selectable>submask</selectable>
                    <selectable>intermediate key</selectable>
                    <selectable>BEV</selectable>
                  </selectables> prior to <assignable>activity requiring validation</assignable>.
                  </title>                  
                </ext-comp-def-title>
                
                <note role="application">
                    This SFR is claimed when the TSF validates an authentication factor as a prerequisite to unlocking the key chain as
                    defined in FCS_KYC_EXT.1.
                </note>
                
              </f-element>
              <f-element id="fcs-val-ext-1-3">
                <title>The TSF shall 
                  <selectables linebreak="yes">
                    <selectable>perform a key sanitization of the DEK upon a 
                      <selectables>
                        <selectable>configurable number</selectable>
                        <selectable><assignable>ST author specified number</assignable></selectable>
                      </selectables>
                      of consecutive failed validation attempts
                    </selectable>
                    <selectable>institute a delay such that only <assignable>ST author specified number of attempts</assignable> can be made within a 24 hour period</selectable>
                    <selectable>block validation after <assignable>ST author specified number of attempts</assignable> of consecutive failed validation attempts</selectable>
                    <selectable>require power cycle or reset the TOE after <assignable>ST author specified number of attempts</assignable> of consecutive failed validation attempts</selectable>
                  </selectables>.</title>
                <note role="application">
                  <h:p>
                    The purpose of performing secure validation is to not expose any material that might compromise the submasks. For the selections in FCS_VAL_EXT.1.1, the ST author must clarify in the KMD which specific entities are referred to in this SFR if multiple entities of a type exist.
                  </h:p>
                  <h:p>The TOE validates the submasks (e.g., authorization factors) prior to presenting the BEV to the EE. When a password is used as an authorization factor, it is conditioned before any attempts to validate. In cases where validation of the authorization factors fails, the product will not forward a BEV to EE. </h:p>
                  <h:p>When the key wrap in FCS_COP.1/KeyWrap is used, the validation is performed inherently.</h:p>
                  <h:p>The delay must be enforced by the TOE, but this requirement is not intended to address attacks that bypass the product (e.g. attacker obtains hash value or “known” crypto value and mounts attacks outside of the TOE, such as a third party password crackers). The cryptographic functions (i.e., hash, decryption) performed are those specified in FCS_COP.1/Hash, FCS_COP.1/KeyedHash, and FCS_COP.1/SKC.</h:p>
                  <h:p>The ST author may need to iterate this requirement if multiple authentication factors are used, and either different methods are used to validate, or in some cases one or more authentication factors may be validated, and one or more are not validated.</h:p>
                </note>
              </f-element>
             
            </f-component>
      </section>
    
    <section title="User Data Protection" id="FDP">
      <ext-comp-def title="Protection of Data on Disk" fam-id="FDP_DSK_EXT">
        <fam-behavior>This family specifies methods for ensuring that data residing in permanent storage on disk is
          not subject to unauthorized disclosure.
        </fam-behavior>
      </ext-comp-def>
      
    <f-component cc-id="fdp_dsk_ext.1" name="Protection of Data on Disk" id="fdp-dsk-ext-1">
      <consistency-rationale/>
      <comp-lev>requires the TSF to validate submasks and BEVs by one or
        more of the specified methods.</comp-lev>
      <management/>
      <audit/>
      <dependencies>FCS_COP.1 Cryptographic Operation</dependencies>
      <f-element id="fdp-dsk-ext-1-1">
        <title>
          The TSF shall perform full drive encryption in accordance with FCS_COP.1<h:b>/SKC</h:b>, such 
          that the drive contains no plaintext protected data.
        </title>
        <ext-comp-def-title>
          <title>
            The TSF shall perform Full Drive Encryption in accordance with
            FCS_COP.1, such that the drive contains no plaintext protected data.
          </title>
        </ext-comp-def-title>
      </f-element>
      
      <f-element id="fdp-dsk-ext-1-2">
        <title>
          The TSF shall encrypt all protected data without user intervention.
        </title>
        <note role="application">
          The intent of this requirement is to specify that encryption of any protected
          data will not depend on a user electing to protect that data. The drive encryption specified in
          FDP_DSK_EXT.1 occurs transparently to the user and the decision to protect the data is
          outside the discretion of the user, which is a characteristic that distinguishes it from file
          encryption. The definition of protected data can be found in the glossary.<h:br/><h:br/>
          The cryptographic functions that perform the encryption/decryption of the data may be
          provided by the Operational Environment. Note that if this is the case, it is assumed that the
          environmental implementation of AES is consistent with the behavior described in
          FCS_COP.1/SKC. If the TOE provides the cryptographic functions to encrypt/decrypt the data,
          the ST author includes FCS_COP.1/SKC as defined in Appendix B in the main body of the ST.
        </note>
        <aactivity>
          <TSS>
            The evaluator shall examine the TSS to ensure that the description is comprehensive in how the
            data is written to the disk and the point at which the encryption function is applied. The TSS
            must make the case that standard methods of accessing the disk drive via the host platforms 
            operating system will pass through these functions.<h:br/><h:br/>
            For the cryptographic functions that are provided by the Operational Environment, the evaluator
            shall check the TSS to ensure it describes, for each platform identified in the ST, the interfaces
            used by the TOE to invoke this functionality.<h:br/><h:br/>
            66 The evaluator shall verify the TSS in performing the evaluation activities for this requirement.
            The evaluator shall ensure the comprehensiveness of the description, confirms how the TOE writes the
            data to the disk drive, and the point at which it applies the encryption function.<h:br/><h:br/>
            The evaluator shall verify that the TSS describes the initialization of the TOE and the activities 
            the TOE performs to ensure that it encrypts all the storage devices entirely when a user or 
            administrator first provisions the TOE. The evaluator shall verify the TSS describes areas of the 
            disk that it does not encrypt (e.g., portions associated with the Master Boot Records (MBRs), boot
            loaders, partition tables, etc.). If the TOE supports multiple disk encryptions, the evaluator shall
            examine the administration guidance to ensure the initialization procedure encrypts all storage devices
            on the platform.
          </TSS>
          <Guidance>
            The evaluator shall review the AGD guidance to determine that it describes the initial steps needed to 
            enable the FDE function, including any necessary preparatory steps. The guidance shall provide instructions 
            that are sufficient, on all platforms, to ensure that all hard drive devices will be encrypted when encryption
            is enabled.
          </Guidance>
          <KMD>
            The evaluator shall verify the KMD includes a description of the data encryption engine, its components, and 
            details about its implementation (e.g. for hardware: integrated within the device’s main SOC or separate 
            co-processor, for software: initialization of the product, drivers, libraries (if applicable), logical interfaces 
            for encryption/decryption, and areas which are not encrypted (e.g. boot loaders, portions associated with the Master 
            Boot Record (MBRs), partition tables, etc.)). The evaluator shall verify the KMD provides a functional (block) diagram 
            showing the main components (such as memories and processors) and the data path between, for hardware, the device’s 
            host interface and the device’s persistent media storing the data, or for software, the initial steps needed to the
            activities the TOE performs to ensure it encrypts the storage device entirely when a user or administrator first 
            provisions the product. The hardware encryption diagram shall show the location of the data encryption engine within 
            the data path. The evaluator shall validate that the hardware encryption diagram contains enough detail showing the 
            main components within the data path and that it clearly identifies the data encryption engine.<h:br/><h:br/>
            The evaluator shall verify the KMD provides sufficient instructions for all platforms to ensure that when the user 
            enables encryption, the product encrypts all hard storage devices. The evaluator shall verify that the KMD describes
            the data flow from the device’s host interface to the device’s persistent media storing the data. The evaluator shall 
            verify that the KMD provides information on those conditions in which the data bypasses the data encryption engine 
            (e.g., read-write operations to an unencrypted Master Boot Record area).<h:br/><h:br/>
            The evaluator shall verify that the KMD provides a description of the platform’s boot initialization, the encryption 
            initialization process, and at what moment the product enables the encryption. The evaluator shall validate that the 
            product does not allow for the transfer of user data before it fully initializes the encryption. The evaluator shall
            ensure the software developer provides special tools which allow inspection of the encrypted drive either in-band or
            out-of-band, and may allow provisioning with a known key.
          </KMD>
          <Tests>
            The evaluator shall perform the following tests:
            <testlist>
              <test>
                Write data to random locations, perform required actions and compare:<h:ul>
                <h:li>Ensure TOE is initialized and, if hardware, encryption engine is ready</h:li>
                <h:li>Provision TOE to encrypt the storage device. For SW Encryption products, or hybrid products use a known 
                  key and the developer tools.</h:li>
                <h:li>Determine a random character pattern of at least 64 KB</h:li>
                <h:li>Retrieve information on what the device TOE’s lowest and highest logical address is for which encryption is enabled.</h:li>
                </h:ul>
              </test>
              <test>
                Write pattern to storage device in multiple locations:<h:ul>
                <h:li>For HW Encryption, randomly select several logical address locations within the device’s lowest to highest address 
                  range and write pattern to those addresses</h:li>
                <h:li>For SW Encryption, write the pattern using multiple files in multiple logical locations.</h:li>
                </h:ul>              
              </test>
              <test>
                Verify data is encrypted:<h:ul>
                <h:li>For HW Encryption:<h:ul>
                  <h:li>engage device’s functionality for generating a new encryption key, thus
                    performing an erase of the key per FCS_CKM.4/Power</h:li>
                  <h:li>Read from the same locations at which the data was written</h:li>
                  <h:li>Compare the retrieved data to the written data and ensure they do not
                    match</h:li>
                </h:ul></h:li>
                
                <h:li>For SW Encryption, using developer tools:<h:ul>
                  <h:li>Review the encrypted storage device for the plaintext pattern at each location where the file was written
                    and confirm plaintext pattern cannot be found.</h:li>
                  <h:li>Using the known key, verify that each location where the file was written, the plaintext pattern can be 
                    correctly decrypted using the key.</h:li>
                  <h:li>If available in the developer tools, verify there are no plaintext files
                    present in the encrypted range.</h:li></h:ul></h:li>                
                </h:ul>
              </test>
            </testlist>
          </Tests>
        </aactivity>
      </f-element>      
    </f-component>
    </section>
    
      <section title="Security Management (FMT)" id="FMT">        
        
        <f-component cc-id="fmt_smf.1" name="Specification of Management Functions" id="fmt-smf-1">
        <f-element id="fmt-smf-1">
          <title>
          The TSF shall be capable of performing the following management functions: [
            <h:i><h:ol type='a'>
              <h:li>change the DEK, as specified in FCS_CKM.1, when re-provisioning or when commanded</h:li>
              <h:li>erase the DEK, as specified in FCS_CKM.6<h:b>/Power</h:b></h:li>              
              <h:li>initiate TOE firmware/software updates</h:li>
              <h:li><selectables>
                <selectable>no other functions</selectable>
                <selectable>configure a password for firmware update</selectable>
                <selectable>import a wrapped DEK</selectable>
                <selectable>configure cryptographic functionality</selectable>
                <selectable>disable key recovery functionality</selectable>
                <selectable>securely update the public key needed for trusted update</selectable>
                <selectable>configure the number of failed validation attempts required to trigger corrective behavior</selectable>
                <selectable>configure the corrective behavior to issue 1 in the event of an excessive number of
                  failed validation attempts</selectable>
                <selectable><assignable>other management functions provided by the TSF</assignable></selectable>
              </selectables>]</h:li>
            </h:ol></h:i> 
            
          </title>
          <note role="application">
              The intent of this requirement is to express the management capabilities that the TOE possesses. 
              This means that the TOE must be able to perform the listed functions. Item (d) is used to specify
              functionality that may be included in the TOE, but is not required to conform to the cPP. “Configure
              cryptographic functionality” could include key management functions; for example, the BEV will be 
              wrapped or encrypted, and the EE will need to unwrap or decrypt the BEV. In item (d), if no other
              management functions are provided (or claimed), then “no other functions” should be
              selected. Default Authorization factors are the initial values that are used to
              manipulate the drive.<h:br/><h:br/>            
              For the purposes of this document, key sanitization means to destroy the DEK, using one of the 
              approved destruction methods. This applies to instances of the protected key that
              exist in non-volatile storage.
          </note>
            <aactivity>
                <TSS>
                  <h:p>If item a&#41; is selected in FMT_SMF.1.1: The evaluator shall ensure the TSS describes
                    how the TOE changes the DEK.</h:p>
                  <h:p>If item b&#41; is selected in FMT_SMF.1.1: The evaluator shall ensure the TSS describes
                    how the TOE cryptographically erase the DEK.</h:p>
                  <h:p>If item c&#41; is selected in FMT_SMF.1.1: The evaluator shall ensure the TSS describes
                    the process to initiate TOE firmware/software updates.</h:p>
                  <h:p>If item d&#41; is selected in FMT_SMF.1.1: If additional management functions
                  are claimed in the ST, the evaluator shall verify that the TSS describes those
                  functions.</h:p>                  
                </TSS>
                <Guidance>
                  <h:p>If item a&#41; is selected in FMT_SMF.1.1: The evaluator shall review the AGD guidance
                    and shall determine that the instructions for changing a DEK exist. The instructions must
                    cover all environments on which the TOE is claiming conformance, and include any 
                    preconditions that must exist in order to successfully generate or re-generate the DEK.</h:p>
                  <h:p>If item c&#41; is selected in FMT_SMF.1.1: The evaluator shall examine the operational 
                    guidance to ensure that it describes how to initiate TOE firmware/software updates.</h:p>
                  <h:p>If item d&#41; is selected in FMT_SMF.1.1: Default Authorization Factors: It may be the
                    case that the TOE arrives with default authorization factors in place. If it does, then the
                    selection in item D must be made so that there is a mechanism to change these authorization
                    factors. The operational guidance shall describe the method by which the user changes these
                    factors when they are taking ownership of the device. The TSS shall describe the default 
                    authorization factors that exist.</h:p>                  
                  <h:p>Disable Key Recovery: The guidance for disabling this capability shall be described in
                    the AGD documentation.</h:p>                  
                </Guidance>
              <KMD>If item d)&#41; is selected in FMT_SMF.1.1: If the TOE offers the functionality to import 
                an encrypted DEK, the evaluator shall ensure the KMD describes how the TOE imports a wrapped
                DEK and performs the decryption of the wrapped DEK.</KMD>
                <Tests>
                  <h:p>
                    If item a&#41; and/or b&#41; is selected in FMT_SMF.1.1: The evaluator shall verify that the 
                    TOE has the functionality to change and cryptographically erase the DEK (effectively removing
                    the ability to retrieve previous user data).
                  </h:p>
                  <h:p>If item c&#41; is selected in FMT_SMF.1.1: The evaluator shall verify that the TOE has the
                    functionality to initiate TOE firmware/software updates.</h:p>
                  <h:p>If item d&#41; is selected in FMT_SMF.1.1: If additional 
                    management functions are claimed, the evaluator shall verify
                    that the additional features function as described.</h:p>
                </Tests>
            </aactivity>
        </f-element>          
      </f-component>
      </section>
    
      <section title="Protection of the TSF (FPT)" id="fpt">
        <ext-comp-def title="Firmware Access Control" fam-id="FPT_FAC_EXT">
          <fam-behavior>This family requires that a valid authentication factor be provided prior to the TSF authorizing
            an update of its firmware.</fam-behavior>
        </ext-comp-def>
        
        <ext-comp-def title="Firmware Update Authentication" fam-id="FPT_FUA_EXT">
          <fam-behavior>This family requires that firmware updates be authenticated by the TSF prior to being applied.</fam-behavior>
        </ext-comp-def>
        
        <ext-comp-def title="Key and Key Material Protection" fam-id="FPT_KYP_EXT">
          <fam-behavior>This family requires that key and key material be protected if and when written to non-volatile storage.
            </fam-behavior>
        </ext-comp-def>
        <ext-comp-def title="Power Management" fam-id="FPT_PWR_EXT">
          <fam-behavior>This family defines secure behavior of the TSF when the TOE supports multiple power saving states. The use of compliant power saving states (i.e. power saving states that purge security relevant data upon entry) is essential for ensuring that state transitions cannot be used as attack vectors to bypass TOE self-protection mechanisms.
            </fam-behavior>
        </ext-comp-def>
        
        <ext-comp-def title="Rollback Protection" fam-id="FPT_RBP_EXT">
          <fam-behavior>This family requires that the TSF protects against rollbacks or downgrades
            to its firmware.</fam-behavior>
        </ext-comp-def>
        
        <ext-comp-def title="Trusted Update" fam-id="FPT_TUD_EXT">
          <fam-behavior>Components in this family address the requirements for updating the TOE firmware and/or software.
            </fam-behavior>
        </ext-comp-def>
        
        <f-component name="Firmware Access Control" cc-id="fpt_fac_ext.1" id="fpt-fac-ext" status="optional">
          <consistency-rationale/>
          <comp-lev>requires the TSF to require an authentication factor prior to allowing a
            firmware update to be performed.</comp-lev>
          <management>
            The following actions could be considered for the management functions in FMT:
            <h:ul>
              <h:li>management of the password used to authorize the firmware update</h:li>
            </h:ul>
          </management>
          <audit/>
          <dependencies>No dependencies.</dependencies>
          <f-element id="fpt_fac-1-1">
            <title>
              The TSF shall require <selectables>
                <selectable>a password</selectable>
                <selectable>a known unique value printed on the device</selectable>
                <selectable>a privileged user action</selectable>
              </selectables> before the firmware update proceeds.
            </title>
            <note role="application">
              Before an update takes place, the drive owner will authorize the update by providing either a known unique 
              value (for example, a serial number) that is printed on the collaborative Protection Profile for Full Drive 
              Encryption - Encryption Engine drive, a password (which should be administratively configurable as defined 
              in FMT_SMF.1) or perform the operation as a privileged user. It is assumed that physical presence to the drive
              is limited to authorized personnel. If the correct value is not provided, the update will not take place. The
              values are intended to be unique per drive so they cannot be easily exhausted.<h:br/><h:br/>
              The same requirements for cleaning up a password still apply.
            </note>
            <aactivity>
              <TSS>
                The evaluator shall examine the TSS to ensure that it describes information stating how the Access Control 
                process takes place along with a description of the values that are used.
              </TSS>
              <Guidance>
                The evaluator ensures that the Operational Guidance describes how the user will be expected to interact with
                the authorization process.
              </Guidance>
              <KMD/>
              <Tests>
                The evaluator shall perform the following test.
                <testlist>
                  <test>
                    The evaluator shall try installing a firmware upgrade and verify that a prompt is required and the appropriate
                    value is necessary for the update to continue.
                  </test>
                </testlist>
              </Tests>
            </aactivity>
          </f-element>
        </f-component>
        
        
        <f-component cc-id="fpt_fls.1" name="Failure with Preservation of Secure State" status="sel-based">
          <depends on-sel="fcs-kdf-ext-1"></depends>
          <f-element id="fel-pres-sec-state">
            <title>
              The TSF shall preserve a secure state when the following types of failures occur: [<h:i>DRBG self-test failure</h:i>].              
            </title>
            <note role="application">The intent of this requirement is to ensure that cryptographic services requiring random bit generation cannot be performed if a failure of a self-test defined in FPT_TST.1 occurs.</note>
            <aactivity>              
              <TSS>
                The evaluator shall verify that the TSF describes how the TOE enters an error state in the event of a DRBG self-test failure.
              </TSS>
              <Guidance>
                The evaluator shall verify that the guidance documentation describes the error state that results from a DRBG self-test failure and the actions that a user or administrator should take in response to attempt to resolve the error state.
              </Guidance>
              <Tests/>
            </aactivity>
          </f-element>
        </f-component>
        
        <f-component name="Firmware Update Authentication" cc-id="fpt_fua_ext.1" id="fpt-fua-1" status="sel-based">
          <depends on-sel="fpt-tud-ext-1-3"/>          
          <consistency-rationale/>
          <comp-lev>requires the TSF to authenticate firmware updates using a specified method.</comp-lev>
          <management/>
          <audit/>
          <dependencies>
            FCS_COP.1 Cryptographic Operation
          </dependencies>
          <f-element id="fpt_fua-ext-1-1">
            <title>
              The TSF shall authenticate the source of the firmware update using the
              digital signature algorithm specified in FCS_COP.1<h:b>/SigVer</h:b> using the RTU
              that contains <selectables>
                <selectable>the public key</selectable>
                <selectable>hash value of the public key as specified in FCS_COP.1<h:b>/Hash</h:b></selectable>
              </selectables>              
            </title>
            <ext-comp-def-title>
              <title>The TSF shall authenticate the source of the firmware update using the
                digital signature algorithm specified in FCS_COP.1 using the RTU
                that contains <selectables>
                  <selectable>the public key</selectable>
                  <selectable>hash value of the public key as specified in FCS_COP.1</selectable>
                </selectables></title>
            </ext-comp-def-title>
          </f-element>
            <f-element id="fpt_fua-ext-1-2">
              <title>
                The TSF shall only allow installation of update if the digital signature
                has been successfully verified as specified in FCS_COP.1<h:b>/SigVer</h:b>.
              </title>
              <ext-comp-def-title>
                <title>The TSF shall only allow installation of update if the digital signature
                  has been successfully verified as specified in FCS_COP.1.</title>
              </ext-comp-def-title>
            </f-element>
              <f-element id="fpt_fua-ext-1-3">
                <title>
                  The TSF shall only allow modification of the existing firmware after
                  the successful validation of the digital signature, using a mechanism as described in
                  FPT_TUD_EXT.1.2.
                </title>
                <note role="application">
                  The firmware portion of the TOE (e.g., RTU (key store and the signature
                  verification algorithm)) is expected to be stored in a write protected area on the TOE. It is
                  expected that the firmware only be modifiable in a post-manufacturing state using the
                  authenticated update mechanism described in FPT_FUA_EXT.1. The TSF is modifiable only
                  by using the mechanisms specified in FPT_TUD_EXT.
                </note>
              </f-element>
                <f-element id="fpt_fua-ext-1-4">
                  <title>
                    The TSF shall return an error code if any part of the firmware update process
                    fails.
                  </title>
                  <note role="application">
                    This SFR must be claimed if "authenticated firmware update mechanism as
                    described in FPT_FUA_EXT.1" is claimed in FPT_TUD_EXT.1.3.<h:br/><h:br/>
                    These requirements are for an SED in an operational state – not a drive in manufacturing.<h:br/><h:br/>
                    The authenticated firmware update mechanism employs digital signatures to ensure the
                    authenticity of the firmware update image. The TSF provides a RTU that contains a signature
                    verification algorithm and a key store that includes the public key needed to verify the signature
                    on the update image. The key store in the RTU should include a public key used to verify the
                    signature on an update image or a hash of the public key if a copy of the public key is provided
                    with the update image. In the latter case, the update mechanism should hash the public key
                    provided with the update image, and ensure that it matches a hash which appears in the key
                    store before using the provided public key to verify the signature on the update image. If the
                    hash of the public key is selected, the ST author may iterate the FCS_COP.1/Hash requirement -
                    to specify the hashing functions used.<h:br/><h:br/>
                    The intent of this requirement is to specify that the authenticated update mechanism should
                    ensure that the new image has been digitally signed; and that the digital signature can be
                    verified by using a public key before the update takes place. The requirement also specifies
                    that the authenticated update mechanism only allows installation of updates when the digital
                    signature has been successfully verified by the TSF.
                  </note>
            <aactivity>
              <TSS>
                The evaluator shall examine the TSS to ensure that it describes how the TOE uses the RTU, what type
                of key or hash value, and where the value is stored on the RTU. The evaluator shall also verify that
                the TSS contains a description (storage location) of where the original firmware exists.
              </TSS>
              <Guidance/>
              <KMD/>
              <Tests/>
            </aactivity>
          </f-element>
        </f-component>
        
        
        <f-component cc-id="fpt_kyp_ext.1" name="Protection of Key and Key Material " id="fpt-kyp-ext-1">
          <consistency-rationale/>
          <comp-lev>requires the TSF to ensure that no plaintext key or key material are written to non-volatile storage.</comp-lev>
          <management/>
          <audit/>
          <dependencies>
            <h:p>FCS_COP.1 Cryptographic Operation</h:p>
            <h:p>FCS_KYC_EXT.1 Key Chaining (Initiator)</h:p>
            <h:p>FCS_KYC_EXT.2 Key Chaining (Recipient)</h:p>
            <h:p>FCS_SMC_EXT.1 Submask Combining</h:p>            
          </dependencies>
          
          <f-element id="fpt-kyp-ext-1-1">
            <title>
              The TSF shall <selectables linebreak="yes">
                <selectable id="sel-fpt-kyp-ext-1-1-sel-1">not store keys in non-volatile memory</selectable>
                <selectable id="sel-fpt-kyp-ext-1-1-sel-2">only store keys in non-volatile memory when wrapped, as specified in FCS_COP.1<h:b>/KeyWrap</h:b>, or encrypted, as specified in FCS_COP.1<h:b>/KeyEnc</h:b> or FCS_COP.1<h:b>/KeyEncap</h:b></selectable>
                <selectable id="sel-fpt-kyp-ext-1-1-sel-3">only store plaintext keys that meet any one of the following criteria <selectables>
                  <selectable id="sel-fpt-kyp-ext-1-1-sel-3a">the plaintext key is not part of the key chain as specified in FCS_KYC_EXT.2</selectable>
                  <selectable id="sel-fpt-kyp-ext-1-1-sel-3b">the plaintext key will no longer provide access to the encrypted data after initial provisioning</selectable>
                  <selectable id="sel-fpt-kyp-ext-1-1-sel-3c">the plaintext key is a key split that is combined as specified in FCS_SMC_EXT.1, and the other half of the key split is <selectables linebreak="yes">
                    <selectable id="sel-fpt-kyp-ext-1-1-sel3ci-">wrapped as specified in FCS_COP.1<h:b>/KeyWrap</h:b></selectable>
                    <selectable id="sel-fpt-kyp-ext-1-1-sel-3cii">encrypted as specified in FCS_COP.1<h:b>/KeyEnc</h:b> or FCS_COP.1<h:b>/KeyEncap</h:b></selectable>
                    <selectable id="sel-fpt-kyp-ext-1-1-sel-3ciii">derived and not stored in non-volatile memory</selectable>
                  </selectables></selectable>
                  <selectable id="sel-fpt-kyp-ext-1-1-sel-3d">the non-volatile memory the key is stored on is located in an external storage device for use as an authorization factor</selectable>
                  <selectable id="sel-fpt-kyp-ext-1-1-sel-3e">the plaintext key is <selectables linebreak="yes">
                    <selectable id="sel-fpt-kyp-ext-1-1-sel-3ei">used to wrap a key as specified in FCS_COP.1<h:b>/KeyWrap</h:b></selectable>
                    <selectable id="sel-fpt-kyp-ext-1-1-sel-3eii">used to encrypt a key as specified in FCS_COP.1<h:b>/KeyEnc</h:b> or FCS_COP.1<h:b>/KeyEncap</h:b></selectable></selectables>
                     that is <selectables linebreak='yes'>
                       <selectable id="sel-fpt-kyp-ext-1-1-sel-3eiii">already wrapped as specified in FCS_COP.1<h:b>/KeyWrap</h:b>,</selectable>
                       <selectable id="sel-fpt-kyp-ext-1-1-sel-3eiv">already encrypted as specified in FCS_COP.1<h:b>/KeyEnc</h:b> or FCS_COP.1<h:b>/KeyEncap</h:b>,</selectable>                       
                     </selectables>
                 </selectable>                  
                </selectables>
                </selectable>
              </selectables>.
            </title>
            
            <ext-comp-def-title>
              <title>The TSF shall <selectables linebreak="yes">
                <selectable>not store keys in non-volatile memory</selectable>
                <selectable>only store keys in non-volatile memory when wrapped, as specified in FCS_COP.1, or encrypted, as specified in FCS_COP.1</selectable>
                <selectable>only store plaintext keys that meet any one of the following criteria <selectables>
                  <selectable>the plaintext key is not part of the key chain as specified in FCS_KYC_EXT.2</selectable>
                  <selectable>the plaintext key will no longer provide access to the encrypted data after initial provisioning</selectable>
                  <selectable>the plaintext key is a key split that is combined as specified in FCS_SMC_EXT.1, and the other half of the key split is <selectables linebreak="yes">
                    <selectable>wrapped as specified in FCS_COP.1</selectable>
                    <selectable>encrypted as specified in FCS_COP.1 or FCS_COP.1</selectable>
                    <selectable>derived and not stored in non-volatile memory</selectable>
                  </selectables></selectable>
                  <selectable>the non-volatile memory the key is stored on is located in an external storage device for use as an authorization factor</selectable>
                  <selectable>the plaintext key is <selectables linebreak="yes">
                    <selectable>used to wrap a key as specified in FCS_COP.1</selectable>
                    <selectable>used to encrypt a key as specified in FCS_COP.1 or FCS_COP.1</selectable></selectables>
                    that is already <selectables linebreak='yes'>
                      <selectable>wrapped as specified in FCS_COP.1,</selectable>
                      <selectable>encrypted as specified in FCS_COP.1,</selectable>                      
                    </selectables>
                  </selectable>                  
                </selectables>
                </selectable>
                
              </selectables>.
              </title>
            </ext-comp-def-title>
            
            <note role="application">
              The plaintext key storage in non-volatile memory is allowed for several reasons. If the keys exist within protected memory that is not user accessible on the TOE 
              or OE, the only methods that allow it to play a security relevant role for protecting the BEV or the DEK are if it is a key split or providing additional layers 
              of wrapping or encryption on keys that have already been protected.<h:br/><h:br/>
            
              If the TSF implements key wrapping, key encryption, or key encapsulation to maintain protected cryptographic key storage, then FCS_COP.1/KeyWrap, FCS_COP.1/KeyEnc,
              or FCS_COP.1/KeyEncap must be claimed. Additionally, if key wrapping or key encryption is used, then FCS_CKM.1/SKG, FCS_RBG.1, and FCS_COP.1/SKC must be claimed to
              support generation, encryption, and decryption of symmetric keys used in support of these operations. If the TSF implements submask combining to maintain protected
              cryptographic key storage, then FCS_SMC_EXT.1 must be claimed.
            </note>
             
              <aactivity>
                <TSS>
                  The evaluator shall examine the TSS to verify that it describes the method by which intermediate
                  keys are generated using submask combining.
                </TSS>
                <Guidance>There are no AGD evaluation activities for this SFR.</Guidance>
                <KMD>
                  The evaluator shall examine the KMD for a description of the methods used to protect keys stored
                  in non-volatile memory.<h:br/><h:br/>
                  The evaluator shall verify the KMD to ensure it describes the storage location of all keys and 
                  the protection of all keys stored in non-volatile memory. The description of the key chain shall
                  be reviewed to ensure the selected method is followed for the storage of wrapped or encrypted 
                  keys in non-volatile memory and plaintext keys in non-volatile memory meet one of the criteria
                  for storage.
                </KMD>
                <Tests/>                  
                </aactivity>
          </f-element>
         
        </f-component>
        
        <f-component cc-id="fpt_pwr_ext.1" name="Power Saving States" id="fpt-pwr-ext-1">
          <consistency-rationale/>
          <comp-lev>defines the compliant power saving states that are implemented by the TSF.</comp-lev>
          <management>The following actions could be considered for the management functions in FMT:<h:ul>
            <h:li>Enable or disable the use of individual power saving states</h:li>
            <h:li>Specify one or more power saving state configurations</h:li>
          </h:ul></management>
          <audit>There are no auditable events foreseen.</audit>
          <dependencies>No dependencies</dependencies>
          <f-element id="fpt-pwr-ext-1-1">
            <title>
              The TSF shall define the following compliant power saving states: <selectables choose-one-of="yes">
                <selectable>S3</selectable>
                <selectable>S4</selectable>
                <selectable>G2(S5)</selectable>
                <selectable>G3</selectable>
                <selectable>D0</selectable>
                <selectable>D1</selectable>
                <selectable>D2</selectable>
                <selectable>D3</selectable>
                <selectable><assignable>other power saving states</assignable></selectable>
              </selectables>.
            </title>
            <note role="application">Power saving states S3, S4, G2(S5), G3, D0, D1, D2, and D3 are defined
              by the Advanced Configuration and Power Interface (ACPI) standard.</note>
            <aactivity>
            <TSS>The evaluator shall validate the TSS contains a list of compliant power saving states.</TSS>
            <Guidance>The evaluator shall ensure that guidance documentation contains a list of compliant
                power saving states. If additional power saving states are supported, then the evaluator
                shall validate that the guidance documentation states how the use of non-compliant power
                saving states can be avoided.</Guidance>
              <KMD/>
              <Tests>The evaluator shall confirm that for each listed compliant state all key/key materials
                are removed from volatile memory by using the test indicated by the selection in FCS_CKM_EXT.6.</Tests> 
              </aactivity></f-element>         
        </f-component>
        
        <f-component cc-id="fpt_pwr_ext.2" name="Timing of Power Saving States" id="fpt-pwr-ext-2-1">
          <consistency-rationale/>
          <comp-lev>describes the situations that cause compliant power saving states to be entered.</comp-lev>
          <management/>
          <audit>The following actions should be auditable if FAU_GEN Security audit data generation is included in the PP/ST:<h:ul>
            <h:li>Transition of the TSF into different power saving states</h:li>
          </h:ul></audit>
          <dependencies>FPT_PWR_EXT.1 Power Saving States</dependencies>
          <f-element id="fpt-pwr-ext-2-1">
            <title>
              For each compliant power saving state defined in FPT_PWR_EXT.1.1, the TSF shall enter
              the compliant power saving state when the following conditions occur: user-initiated request, <selectables>
                <selectable>shutdown</selectable>
                <selectable>user inactivity</selectable>
                <selectable>request initiated by remote management system</selectable>
                <selectable><assignable>other conditions</assignable></selectable>
                <selectable>no other conditions</selectable>

              </selectables>.
            </title>
            <note role="application">If volatile memory is not cleared as part of an unexpected power shutdown sequence then guidance documentation must define mitigation activities (e.g. how long users should wait after an unexpected power-down before volatile memory can be considered cleared).</note>
              <aactivity>
                <TSS>The evaluator shall validate that the TSS contains a list of conditions under which the
                  TOE enters a compliant power saving state. </TSS>
                <Guidance>The evaluator shall check that the guidance contains a list of conditions under 
                  which the TOE enters a Compliant power saving state. Additionally, the evaluator shall 
                  verify that the guidance documentation provides information on how long it is expected
                  to take for the TOE to fully transition into the Compliant power saving state (e.g. how
                  many seconds for the volatile memory to be completely cleared).</Guidance>
                  <KMD/>
                  <Tests>The evaluator shall trigger each condition in the list of identified conditions and ensure
                    the TOE ends up in a compliant power saving state by using the test indicated by
                    the selection in FCS_CKM_EXT.6.</Tests>
              </aactivity>
          </f-element>
        </f-component>
        
        <f-component name="Rollback Protection" cc-id="fpt_rbp_ext.1" id="fpt-rbp-ext-1" status="optional">
          <consistency-rationale/>
          <comp-lev>requires the TSF to detect and prevent unauthorized rollback.</comp-lev>
          <management/>
          <audit/>
          <dependencies>No dependencies.</dependencies>
          <f-element id="fpt_rbp-ext-1-1">
            <title>
              The TSF shall verify that the new firmware package is not downgrading to a lower
              security version number by <assignable>method of verifying the security version number
              is the same as or higher than the currently installed version</assignable>.
            </title>
          </f-element>
          
            <f-element id="fpt_rbp-ext-1-2">
              <title>
                The TSF shall generate and return an error code if the attempted firmware
                update package is detected to be an invalid version.
              </title>
              <note role="application">
                This requirement prevents an unauthorized rollback of the firmware to an
                earlier authentic version. This mitigates against unknowing installation of an earlier authentic
                firmware version that may have a security weakness. It is expected that vendors will increase
                security version numbers with each new update package.<h:br/><h:br/>
                For FPT_RBP_EXT.1.1 the purpose is to verify that the new package has a security version
                number equal to or larger than the security version number of currently installed firmware
                package.<h:br/><h:br/>
                The administrator guidance would include instructions for the administrator to configure the
                rollback prevention mechanism, if appropriate.
              </note>
                        
            <aactivity>
              <TSS>
                The evaluator shall examine the TSS to ensure that it describes at a high level the process for verifying
                that security version checking is performed before an upgrade is installed. The evaluator shall verify that
                a high level description of the types of error codes are provided and when an error would be triggered.
              </TSS>
              <Guidance>
                The evaluator ensures that a description is provided on how the user should interpret the error codes.
              </Guidance>
              <KMD/>
              <Tests>
                The evaluator shall perform the following test:
                <testlist>
                  <test>
                    The evaluator shall try installing a lower security version number upgrade (either by just modifying the
                    version number or by using an upgrade provided by the vendor) and will verify that the lower version cannot
                    be installed and an error is presented to the user.
                  </test>
                </testlist>
              </Tests>
            </aactivity>
          </f-element>
          
          
        </f-component>
        
        
        <f-component cc-id="fpt_tst.1" name="TSF Self-Testing" status="sel-based">
          <depends on-sel="external-seed"/>
          <f-element id="fel-tsf-self-test">
            <title>
              The TSF shall run a suite of the following self-tests <selectables>
                <selectable>during initial start-up</selectable>
                <selectable>periodically during normal operation</selectable>
                <selectable>at the request of the authorized user</selectable>
                <selectable>at the conditions <assignable>conditions under which self-test should occur</assignable></selectable>
              </selectables>
              to demonstrate the correct operation of <selectables>
                <selectable><assignable>parts of  TSF</assignable></selectable>
                <selectable>TSF data</selectable>
              </selectables>: <assignable>list of self-tests run by the TSF</assignable>.              
            </title>
          </f-element>
          
          <f-element id="fel-tsf-ver-int-data">
            <title>
              The TSF shall provide authorized users with the capability to verify the integrity of
              <selectables>
                <selectable><assignable>parts of TSF data</assignable></selectable>
                <selectable>TSF data</selectable>
              </selectables>.
            </title>
          </f-element>
          
          <f-element id="fel-tsf-ver-int">
            <title>
              The TSF shall provide authorized users with the capability to verify the integrity of <selectables>
                <selectable><assignable>parts of TSF </assignable></selectable>
                <selectable>TSF</selectable>
              </selectables>.
            </title>
            <note role="application">This SFR is a required dependency of FCS_RBG.1. It is intended to require that any DRBG implemented by the TOE undergo health testing to ensure that the random bit generation functionality has not been degraded. If the TSF supports multiple DRBGs, this SFR should be iterated to describe the self-test behavior for each.</note>
            <aactivity>
              <TSS>
                <h:p>
                  The	evaluator shall examine the TSS to ensure that it details the self-tests that are run by the TSF along with how they are run. This description should include an outline of what the tests are actually doing. The evaluator shall ensure that the TSS makes an argument that the tests are sufficient to demonstrate that the DRBG is operating correctly.
                </h:p><h:p>
                  Note that this information may also be placed in the entropy documentation specified by <xref to="entropyappendix"/>. 
                </h:p>
              </TSS>
              <Guidance>
                <h:p>
                  If a self-test can be executed at the request of an authorized user, the evaluator shall verify that the operational guidance provides instructions on how to execute that self-test.
                </h:p>
              </Guidance>
              <Tests>
                <h:p>
                  For each self-test, the evaluator shall verify that evidence is produced that the self-test is executed when specified by FPT_TST.1.1.
                </h:p><h:p>
                  If a self-test can be executed at the request of an authorized user, the evaluator shall verify that following the steps documented in the operational guidance to perform the self-test will result in execution of the self-test.
                </h:p>
              </Tests>
            </aactivity>
          </f-element>
          
        </f-component>

        <f-component cc-id="fpt_tud_ext.1" name="Trusted Update" id="fpt-tud-ext-1">
          <consistency-rationale/>
          <comp-lev>requires the capability to be provided to update the TOE firmware and software, including the ability to verify the updates prior to installation.</comp-lev>
          <management>The following actions could be considered for the management functions in FMT:<h:ul>
            <h:li>Ability to update the TOE and to verify the updates</h:li>
          </h:ul></management>
          <audit>The following actions should be auditable if FAU_GEN Security audit data generation is included in the PP/ST: <h:ul>
            <h:li>Initiation of the update process</h:li>
            <h:li>Any failure to verify the integrity of the update</h:li>
          </h:ul></audit>
          <dependencies>FCS_COP.1 Cryptographic Operation</dependencies>
          
          <f-element id="fpt-tud-ext-1-1">
            <title>
             The TSF shall provide [<h:i>authorized users</h:i>] the ability to
              query the current version of the TOE 
                <selectables>
                  <selectable>software</selectable>
                  <selectable>firmware</selectable>
                </selectables>.
            </title>
            
            <ext-comp-def-title>
              <title>The TSF shall provide <assignable>list of subjects</assignable> the ability to
                query the current version of the TOE 
                  <selectables>
                    <selectable>software</selectable>
                    <selectable>firmware</selectable>
                  </selectables>.
                </title>
            </ext-comp-def-title>
            
          </f-element>
          <f-element id="fpt-tud-ext-1-2">
            <title>
              The TSF shall provide [<h:i>authorized users</h:i>] the ability to initiate updates to TOE 
                <selectables>
                  <selectable>software</selectable>
                  <selectable>firmware</selectable>
                </selectables>.
            </title>
            
            <ext-comp-def-title>
              <title>The TSF shall provide <assignable>list of subjects</assignable> the ability to initiate updates to TOE 
                <selectables>
                  <selectable>software</selectable>
                  <selectable>firmware</selectable>
                </selectables>.</title>
            </ext-comp-def-title>
            
          </f-element>
          <f-element id="fpt-tud-ext-1-3">
            <title>
              The TSF shall verify updates to the TOE <selectables>
                <selectable>software</selectable>
                <selectable>firmware</selectable>
              </selectables> using a <selectables>
                <selectable>digital signature <h:b>as specified in FCS_COP.1/SigVer</h:b></selectable>
                <selectable><h:b>authenticated firmware update mechanism as described in FPT_FUA_EXT.1</h:b></selectable>
              </selectables> by the manufacturer prior to installing those updates.
            </title>
            
            <ext-comp-def-title>
              <title>The TSF shall verify updates to the TOE software using a <selectables>
                <selectable>digital signature</selectable>
                <selectable>published hash</selectable>
              </selectables> by the manufacturer prior to installing those updates.</title>
            </ext-comp-def-title>
            
            <note role="application">While this component requires the TOE to implement the update functionality itself, it is acceptable to perform the cryptographic checks using functionality available in the Operational Environment.</note>
              <aactivity>
                <TSS>
                  If "authenticated firmware update mechanism as described in FPT_FUA_EXT.1" is
                  selected, you must claim FPT_FUA_EXT.1.<h:br/><h:br/>
                  <h:p>The evaluator shall examine the TSS to ensure that it describes information stating that
                    an authorized source signs TOE updates and will have an associated digital signature.
                    The evaluator shall examine the TSS contains a definition of an authorized source along
                    with a description of how the TOE uses public keys for the update verification
                    mechanism in the Operational Environment. The evaluator ensures the TSS contains
                    details on the protection and maintenance of the TOE update credentials.</h:p>
                    <h:p>If the Operational Environment performs the signature verification, then the evaluator
                      shall examine the TSS to ensure it describes, for each platform identified in the ST, the
                      interfaces used by the TOE to invoke this cryptographic functionality.</h:p></TSS>
                  <Guidance>
                    <h:p>The evaluator ensures that the operational guidance describes how the TOE obtains
                      vendor updates to the TOE; the processing associated with verifying the digital
                      signature of the updates (as defined in FCS_COP.1/SigVer); and the actions that take place
                      for successful and unsuccessful cases.</h:p></Guidance>
                  <CustomEA name="KMD">There are no KMD evaluation activities for this SFR.</CustomEA>
                  <Tests>
                    <h:p>
                    The evaluators shall perform the following tests (if the TOE supports multiple
                    signatures, each using a different hash algorithm, then the evaluator performs tests for
                    different combinations of authentic and unauthentic digital signatures and hashes, as
                    well as for digital signature alone): </h:p>
                    <testlist>
                      <test>The evaluator performs the version verification activity to determine the current
                        version of the TOE. After the update tests described in the following tests, the evaluator
                        performs this activity again to verify that the version correctly corresponds to that of
                        the update.</test>
                      <test>The evaluator performs the version verification activity to determine the current
                        version of the TOE. After the update tests described in the following tests, the evaluator
                        performs this activity again to verify that the version correctly corresponds to that of
                        the update.</test>
                    </testlist> </Tests>
              </aactivity>
          </f-element>
        
        </f-component>

      </section>

	</sec:SFRs>
  
  <section title="Security Assurance Requirements" id="SARs">
    <h:p>This cPP identifies the Security Assurance Requirements (SARs) to frame the extent to which
      the evaluator assesses the documentation applicable for the evaluation and performs
      independent testing. Individual evaluation activities to be performed are specified within
      each SFR.
  </h:p><h:p>
    <h:b>Note to ST authors: There is a selection in the ASE_TSS that must be completed. One cannot simply reference the SARs in this cPP.</h:b>
  </h:p><h:p>
    The general model for evaluation of TOEs against STs written to conform to this cPP is as follows: after the ST has been approved for evaluation, the ITSEF will obtain the TOE, supporting environmental IT (if required), and the administrative/user guides for the TOE. The ITSEF is expected to perform actions mandated by the Common Evaluation Methodology (CEM) for the ASE and ALC SARs. The ITSEF also performs the Evaluation Activities contained within the SD, which are intended to be an interpretation of the other CEM assurance requirements as they apply to the specific technology instantiated in the TOE. The Evaluation Activities that are captured in the SD also provide clarification as to what the developer needs to provide to demonstrate the TOE is compliant with the cPP.
  </h:p>
  <h:p>
    
    <h:table>
      <h:head><h:b><ctr ctr-type="Table" pre="Table" id="toe-sec">: TOE Security Assurance Requirements</ctr></h:b></h:head>
      <h:tr>
     <h:td><h:b>Functional Class</h:b></h:td>
     <h:td><h:b>Functional Components</h:b></h:td>
    
    </h:tr>
    <h:tr>
     <h:td rowspan="7">Security Target (ASE)</h:td>
     <h:td>Conformance Claims (ASE_CCL.1)</h:td>
    
    </h:tr>
    <h:tr>
     
     <h:td>Extended Components Definition (ASE_ECD.1)</h:td>
    </h:tr>
    <h:tr>
     <h:td>ST Introduction (ASE_INT.1)</h:td>
    </h:tr>
    <h:tr>
      <h:td>Security Objectives for the Operational Environment (ASE_OBJ.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>Stated Security Requirements (ASE_REQ.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>Security Problem Definition (ASE_SPD.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>TOE Summary Specification (ASE_TSS.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>Development (ADV)</h:td>
      <h:td>Basic Functional Specification (ADV_FSP.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td rowspan="2">Guidance Documents (AGD)</h:td>
      <h:td>Operational User Guidance (AGD_OPE.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>Preparative Procedures (AGD_PRE.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td rowspan="2">Life Cycle Support (ALC)</h:td>
      <h:td>Labeling of the TOE (ALC_CMC.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>TOE CM Coverage (ALC_CMS.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>Tests (ATE)</h:td>
      <h:td>Independent Testing – Sample (ATE_IND.1)</h:td>
     </h:tr>
     <h:tr>
      <h:td>Vulnerability Assessment (AVA)</h:td>
      <h:td>Vulnerability Survey (AVA_VAN.1)</h:td>
     </h:tr>
   </h:table>
  </h:p>
    
    <section title="ASE: Security Target" id="ase">
      <h:p>The ST is evaluated as per ASE activities defined in the CEM. In addition, there may be Evaluation Activities specified within the SD that call for necessary descriptions to be included in the TSS that are specific to the TOE technology type.</h:p>
      <h:p>The SFRs in this cPP allow for conformant implementations to incorporate a wide range of acceptable key management approaches as long as basic principles are satisfied. Given the criticality of the key management scheme, this cPP requires the developer to provide a detailed description of their key management implementation. This information can be submitted as an appendix to the ST and marked proprietary, as this level of detailed information is not expected to be made publicly available. See Appendix E for details on the expectation of the developer’s Key Management Description</h:p><h:p>In addition, if the TOE includes a random bit generator Appendix D provides a description of the information expected to be provided regarding the quality of the entropy.</h:p>
      <h:p><h:b>ASE_TSS.1.1C </h:b> The TOE summary specification shall describe how the TOE meets each SFR, <h:b>including a proprietary Key Management Description (Appendix E), and <h:i>[selection: Entropy Essay, list of all of 3rd 9 party software libraries (including version numbers), 3rd 10 party hardware components (including model/version numbers), no other cPP specified proprietary documentation]</h:i>.</h:b></h:p>
    </section>

    <section title="ADV: Development" id="adv">
      <h:p>The design information about the TOE is contained in the guidance documentation available to the end user as well as the TSS portion of the ST, and any additional information required by this cPP that is not to be made public (e.g., Entropy Essay).</h:p>
   
      <a-component cc-id="adv_fsp.1" name="Basic Functional Specification (ADV_FSP.1)">
      <h:p>The functional specification describes the TOE Security Functions Interfaces (TSFIs). It is not necessary to have a formal or complete specification of these interfaces.
        Additionally, because TOEs conforming to this cPP may have interfaces to the Operational Environment that are not directly invoked by TOE users, there is little point 
        specifying that such interfaces be described in and of themselves since only indirect testing of such interfaces may be possible. For this cPP, the evaluation activities
        for this family focus on understanding the interfaces presented in the TSS in response to the functional requirements and the interfaces presented in the AGD documentation.
        No additional “functional specification” documentation is necessary to satisfy the evaluation activities specified.</h:p>
      <h:p>The evaluation activities are associated with the applicable SFRs. Since these are directly associated with the SFRs, the tracing in element ADV_FSP.1.2D is implicitly 
        already done and no additional documentation is necessary.</h:p>
        <a-element type="D">
          <title>The developer shall provide a functional specification.</title>
        </a-element>
        <a-element type="D">
          <title>The developer shall provide a tracing from the functional specification to the
            SFRs.</title>
          <note role="application">As indicated in the introduction to this section, the
            functional specification is comprised of the information contained in the AGD_OPE and
            AGD_PRE documentation. The developer may reference a website accessible to application
            developers and the evaluator. The evaluation activities in the functional requirements
            point to evidence that should exist in the documentation and TSS
            section; since these are directly associated with the SFRs, the tracing in element
            ADV_FSP.1.2D is implicitly already done and no additional documentation is
            necessary.
          </note>
        </a-element>   
        <a-element type="C">
          <title>The functional specification shall describe the purpose and method of use for
            each SFR-enforcing and SFR-supporting TSFI.</title>
        </a-element>
        <a-element type="C">
          <title>The functional specification shall identify all parameters associated with each
            SFR-enforcing and SFR-supporting TSFI.</title>
        </a-element>
        <a-element type="C">
          <title>The functional specification shall provide rationale for the implicit
            categorization of interfaces as SFR-non-interfering.</title>
        </a-element>
        <a-element type="C">
          <title>The tracing shall demonstrate that the SFRs trace to TSFIs in the functional specification.</title>
        </a-element>    
        <a-element type="E">
          <title>The evaluator shall confirm that the information provided meets all requirements
            for content and presentation of evidence.</title>
        </a-element>
        <a-element type="E">
          <title>The evaluator shall determine that the functional specification is an accurate
            and complete instantiation of the SFRs.</title>
          <aactivity>
            <!-- <TSS>-->
            There are no specific evaluation activities associated with these SARs, except
            ensuring the information is provided. The functional specification documentation is
            provided to support the evaluation activities described in <xref to="SFRs"/>, and
            other activities described for AGD, ATE, and AVA SARs. The requirements on the content
            of the functional specification information is implicitly assessed by virtue of the
            other evaluation activities being performed; if the evaluator is unable to perform an
            activity because there is insufficient interface information, then an adequate
            functional specification has not been provided.
            <!-- </TSS> -->
          </aactivity>
        </a-element>
      </a-component>
      
  </section>
    
  <section title="AGD: Guidance Documentation" id="agd">
    <h:p>The guidance documents will be provided with the ST. Guidance must include a description of how the IT personnel verifies that
      the Operational Environment can fulfill its role for the security functionality. The documentation should be in an informal style 
      and readable by the IT personnel.</h:p>
    <h:p>Guidance must be provided for every operational environment that the product supports as claimed in the ST. This guidance
      includes: <h:ul>
      <h:li>Instructions to successfully install the TSF in that environment; and</h:li>
      <h:li>Instructions to manage the security of the TSF as a product and as a component of the larger operational environment</h:li>
      <h:li>Instructions to provide a protected administrative capability.</h:li>
    </h:ul></h:p>
    <h:p>Guidance pertaining to particular security functionality must also be provided; requirements on such guidance are contained in
      the evaluation activities</h:p>
    <a-component cc-id="agd_ope.1" name="Operational User Guidance (AGD_OPE.1)">
      <h:p>The operational user guidance does not have to be contained in a single document. Guidance to users, administrators, and 
        integrators can be spread among documents or web pages.</h:p>
      <h:p>The developer should review the evaluation activities to ascertain the specifics of the guidance that the evaluator will be
        checking for. This will provide the necessary information for the preparation of acceptable guidance.</h:p>
      <a-element type="D">
        <title>The developer shall provide operational user guidance.</title>
        <note role="application">The operational user guidance does not have to be contained in a
          single document. Guidance to users, administrators and application developers can be
          spread among documents or web pages. Where appropriate, the guidance documentation is
          expressed in the eXtensible Configuration Checklist Description Format (XCCDF) to
          support security automation. Rather than repeat information here, the developer should
          review the evaluation activities for this component to ascertain the specifics of the
          guidance that the evaluator will be checking for. This will provide the necessary
          information for the preparation of acceptable guidance.
        </note>
      </a-element>  
      <a-element type="C">
        <title>The operational user guidance shall describe, for each user role, the
          user-accessible functions and privileges that should be controlled in a secure
          processing environment, including appropriate warnings.</title>
        <note role="application">User and administrator are to be considered in the definition
          of user role.</note>
      </a-element>
      <a-element type="C">
        <title>The operational user guidance shall describe, for each user role, how to use the
          available interfaces provided by the TOE in a secure manner.</title>
      </a-element>
      <a-element type="C">
        <title>The operational user guidance shall describe, for each user role, the available
          functions and interfaces, in particular all security parameters under the control of
          the user, indicating secure values as appropriate.</title>
      </a-element>
      <a-element type="C">
        <title>The operational user guidance shall, for each user role, clearly present each
          type of security-relevant event relative to the user-accessible functions that need to
          be performed, including changing the security characteristics of entities under the
          control of the TSF.</title>
      </a-element>
      <a-element type="C">
        <title>The operational user guidance shall identify all possible modes of operation of
          the TOE (including operation following failure or operational
          error), their consequences, and implications for maintaining secure operation.</title>
      </a-element>
      <a-element type="C">
        <title>The operational user guidance shall, for each user role, describe the security
          measures to be followed in order to fulfill the security objectives for the
          operational environment as described in the ST.</title>
      </a-element>
      <a-element type="C">
        <title>The operational user guidance shall be clear and reasonable.</title>
      </a-element>     
      <a-element type="E">
        <title>The evaluator shall confirm that the information provided meets all requirements
          for content and presentation of evidence.</title>
        <aactivity>
          <!--<Guidance>-->
          <h:p>
            Some of the contents of the operational guidance will be verified by the
            evaluation activities in <xref to="SFRs"/> and evaluation of the TOE
            according to the <xref to="bibCEM"/>. The following additional
            information is also required.
          </h:p><h:p>
            If cryptographic functions are provided by the 
            TOE, the operational guidance shall contain instructions for 
            configuring the cryptographic engine associated with the evaluated configuration of 
            the TOE. It shall provide a warning to the administrator that use of 
            other cryptographic engines was not evaluated nor tested during the CC evaluation of 
            the TOE.
          </h:p><h:p>
            The documentation must describe the process for verifying 
            updates to the TOE by verifying a digital signature – this may
            be done by the TOE or the underlying platform. 
          </h:p><h:p>
            The evaluator shall verify that this process includes the following steps: </h:p>
          <h:ul>      
            <h:li>Instructions for obtaining the 
              update itself. This should include instructions for making the update accessible to 
              the TOE (e.g., placement in a specific directory).</h:li>    
            <h:li>Instructions for initiating the update process, as well as discerning whether the process was 
              successful or unsuccessful. This includes generation of the digital signature. 
              The TOE will likely contain security functionality that does not 
              fall in the scope of evaluation under this PP. The operational guidance shall make it 
              clear to an administrator which security functionality is covered by the evaluation 
              activities.</h:li></h:ul>
          <!--	      </Guidance> -->
        </aactivity>
      </a-element>
    </a-component>
    
    <a-component cc-id="agd_pre.1" name="Preparative Procedures (AGD_PRE.1)">As with the operational guidance, the developer should look to the Evaluation Activities to determine the required content with respect to preparative procedures.
      <a-element type="D">
        <title>The developer shall provide the TOE, including its preparative procedures.</title>
        <note role="application">
          As with the operational guidance, the developer should look to
          the evaluation activities to determine the required content with respect to preparative
          procedures.</note>
      </a-element>     
      <a-element type="C">
        <title>The preparative procedures shall describe all the steps necessary for secure
          acceptance of the delivered TOE in accordance with the developer's
          delivery procedures.</title>
      </a-element>
      <a-element type="C">
        <title>The preparative procedures shall describe all the steps necessary for secure
          installation of the TOE and for the secure preparation of the
          operational environment in accordance with the security objectives for the operational
          environment as described in the ST.</title>
      </a-element>    
      <a-element type="E">
        <title>The evaluator shall confirm that the information provided meets all requirements
          for content and presentation of evidence.</title>
      </a-element>
      <a-element type="E">
        <title>The evaluator shall apply the preparative procedures to confirm that the TOE
          can be prepared securely for operation.</title>
        <aactivity>
          <!-- <Guidance> -->
          As indicated in the introduction above, there are significant expectations
          with respect to the documentation—especially when configuring the operational
          environment to support TOE functional requirements. The evaluator 
          shall check to ensure that the guidance provided for the TOE 
          adequately addresses all platforms claimed for the TOE in the ST.
          <!--</Guidance> -->
        </aactivity>
      </a-element>
    </a-component>
    
  </section>
  <section title="Class ALC: Life-cycle Support" id="alc">
    At the assurance level provided for TOEs conformant to this cPP, life-cycle support is limited to end-user-visible aspects of the life-cycle, rather than an examination of the TOE vendor’s development and configuration management process. This is not meant to diminish the critical role that a developer’s practices play in contributing to the overall trustworthiness of a product; rather, it is a reflection on the information to be made available for evaluation at this assurance level.
    <a-component cc-id="alc_cmc.1" name="Labelling of the TOE (ALC_CMC.1)">
      This component is targeted at identifying the TOE such that it can be distinguished from other products or versions from the same vendor and can be easily specified when being procured by an end user. The evaluator performs the CEM work units associated with ALC_CMC.1.
      <a-element type="D">
        <title>The developer shall provide the TOE and a reference for the TOE.</title>
      </a-element>
      <a-element type="C">
        <title>The application shall be labeled with a unique reference.</title>
        <note role="application">
          Unique reference information includes:
          <h:ul>
            <h:li>Application Name</h:li>
            <h:li>Application Version</h:li>
            <h:li>Application Description</h:li>
            <h:li>Platform on which Application Runs</h:li>
            <h:li>Software Identification (SWID) tags, if available</h:li>
          </h:ul>
        </note>
      </a-element>
      <a-element type="E">
        <title>The evaluator shall confirm that the information provided meets all
          requirements for content and presentation of evidence.</title>
        <aactivity>
          <!-- <TSS>--> 
          The evaluator shall check the ST to ensure that it contains an identifier
          (such as a product name/version number) that specifically identifies the version that
          meets the requirements of the ST. Further, the evaluator shall check the operational guidance
          and TOE samples received for testing to ensure that the version
          number is consistent with that in the ST. If the vendor maintains a website
          advertising the TOE, the evaluator shall examine the information on 
          the website to ensure that the information in the ST is sufficient to distinguish the
          product.
          <!--	    </TSS> -->
        </aactivity>
      </a-element>
    </a-component>
    
    <a-component cc-id="alc_cms.1" name="TOE CMS Coverage (ALC_CMS.1)">
      Given the scope of the TOE and its associated evaluation evidence requirements, the evaluator performs the CEM work units associated with ALC_CMS.1.
      <a-element type="D">
        <title>The developer shall provide a configuration list for the TOE.</title>
      </a-element>
      <a-element type="C">
        <title>The configuration list shall include the following: the TOE
          itself; and the evaluation evidence required by the SARs.</title>
      </a-element>
      <a-element type="C">
        <title>The configuration list shall uniquely identify the configuration items.</title>
      </a-element>
      <a-element type="E">
        <title>The evaluator shall confirm that the information provided meets all requirements
          for content and presentation of evidence.</title>
        <aactivity>
          <!-- <TSS> -->
          The "evaluation evidence required by the SARs" in this PP is limited to the
          information in the ST coupled with the guidance provided to administrators and users
          under the AGD requirements. By ensuring that the TOE is specifically
          identified and that this identification is consistent in the ST and in the AGD
          guidance (as done in the evaluation activity for ALC_CMC.1), the evaluator implicitly
          confirms the information required by this component. Life-cycle support is targeted
          aspects of the developer’s life-cycle and instructions to providers of applications
          for the developer’s devices, rather than an in-depth examination of the TSF
          manufacturer’s development and configuration management process.
          This is not meant to diminish the critical role that a developer’s practices play in
          contributing to the overall trustworthiness of a product; rather, it’s a reflection on
          the information to be made available for evaluation.
          <!--	      </TSS>
				<Guidance> -->
          <h:p>
            The evaluator shall ensure that the developer has identified (in guidance documentation for application
            developers concerning the targeted platform) one or more development environments
            appropriate for use in developing applications for the developer’s platform. For each
            of these development environments, the developer shall provide information on how to
            configure the environment to ensure that buffer overflow protection mechanisms in the
            environments are invoked (e.g., compiler flags). The evaluator shall ensure that
            this documentation also includes an indication of whether such protections are on by
            default, or have to be specifically enabled. The evaluator shall ensure that the 
            TSF is uniquely identified (with respect to other products from the 
            TSF vendor), and that documentation provided by the developer in 
            association with the requirements in the ST is associated with the 
            TSF using this unique identification. </h:p> 
          <!-- </Guidance>--> 
        </aactivity>
      </a-element>
    </a-component>
    
    <a-component cc-id="alc_flr.1" name="Basic Flaw Remediation (ALC_FLR.1)" status="optional">
      <a-element type="D">
        <title>The developer shall document and provide flaw remediation procedures addressed to TOE
          developers.</title>
      </a-element>
      <a-element type="C">
        <title>The flaw remediation procedures documentation shall describe the procedures used to
          track all reported security flaws in each release of the TOE.</title>
      </a-element>
      <a-element type="C">
        <title>The flaw remediation procedures shall require that a description of the nature and effect
          of each security flaw be provided, as well as the status of finding a correction to that flaw.</title>
      </a-element>
      <a-element type="C">
        <title>The flaw remediation procedures shall require that corrective actions be identified for
          each of the security flaws.</title>
      </a-element>
      <a-element type="C">
        <title>The flaw remediation procedures documentation shall describe the methods used to
          provide flaw information, corrections and guidance on corrective actions to TOE users.</title>
      </a-element>
      <a-element type="E">
        <title>The evaluator shall confirm that the information provided meets all requirements for
          content and presentation of evidence.</title>
        <aactivity>
          <!-- <TSS> --> 
          The evaluator shall inspect the TSS and verify it identifies how to access the flaw remediation procedures.
          <!--</TSS>
				<Guidance> 
					<h:p>
						None.
					 </Guidance>--> 
        </aactivity> 
      </a-element>  
    </a-component>
    
    <a-component cc-id="alc_flr.2" name="Flaw Reporting Procedures (ALC_FLR.2)" status="optional">
      <a-element type="D">
        <title>
          The developer shall document and provide flaw remediation procedures addressed to TOE
          developers.</title>
      </a-element>
      <a-element type="D">
        <title>
          The developer shall establish a procedure for accepting and acting upon all reports of
          security flaws and requests for corrections to those flaws.
        </title>
      </a-element>
      <a-element type="D">
        <title>
          The developer shall provide flaw remediation guidance addressed to TOE users.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures documentation shall describe the procedures used to track all
          reported security flaws in each release of the TOE.</title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall require that a description of the nature and effect of each
          security flaw be provided, as well as the status of finding a correction to that flaw.</title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall require that corrective actions be identified for each of the
          security flaws.</title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures documentation shall describe the methods used to provide flaw
          information, corrections and guidance on corrective actions to TOE users.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall describe a means by which the developer receives
          from TOE users reports and enquiries of suspected security flaws in the TOE.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The procedures for processing reported security flaws shall ensure that any reported
          flaws are remediated and the remediation procedures issued to TOE users.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The procedures for processing reported security flaws shall provide safeguards that any
          corrections to these security flaws do not introduce any new flaws.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation guidance shall describe a means by which TOE users report to the
          developer any suspected security flaws in the TOE.
        </title>
      </a-element>
      <a-element type="E">
        <title>
          The evaluator shall confirm that the information provided meets all requirements for content and
          presentation of evidence.</title>
        <aactivity>
          <!-- <TSS> -->
          The evaluator shall inspect the TSS and verify it identifies how to access the flaw remediation procedures.
          <!-- </TSS>
				<Guidance> -->
          <h:p>
            The evaluator shall inspect the guidance document and verify it describes how to access the flaw remediation guidance.</h:p>
          <!-- </Guidance>--> 
        </aactivity> 
      </a-element>  
    </a-component>
    
    <a-component cc-id="alc_flr.3" name="Systematic Flaw Remediation (ALC_FLR.3)" status="optional">
      <a-element type="D">
        <title>
          The developer shall document and provide flaw remediation procedures addressed to TOE
          developers.
        </title>
      </a-element>
      <a-element type="D">
        <title>
          The developer shall establish a procedure for accepting and acting upon all reports of security
          flaws and requests for corrections to those flaws.
        </title>
      </a-element>
      <a-element type="D">
        <title>
          The developer shall provide flaw remediation guidance addressed to TOE users.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures documentation shall describe the procedures used to track all
          reported security flaws in each release of the TOE.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall require that a description of the nature and effect of each
          security flaw be provided, as well as the status of finding a correction to that flaw.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall require that corrective actions be identified for each of the
          security flaws.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures documentation shall describe the methods used to provide flaw
          information, corrections and guidance on corrective actions to TOE users.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall describe a means by which the developer receives from
          TOE users reports and enquiries of suspected security flaws in the TOE.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation procedures shall include a procedure requiring timely response and
          the automatic distribution of security flaw reports and the associated corrections to
          registered users who might be affected by the security flaw.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The procedures for processing reported security flaws shall ensure that any reported flaws are
          remediated and the remediation procedures issued to TOE users.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The procedures for processing reported security flaws shall provide safeguards that any
          corrections to these security flaws do not introduce any new flaws.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation guidance shall describe a means by which TOE users report to the
          developer any suspected security flaws in the TOE.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation guidance shall describe a means by which TOE users may register
          with the developer, to be eligible to receive security flaw reports and corrections.
        </title>
      </a-element>
      <a-element type="C">
        <title>
          The flaw remediation guidance shall identify the specific points of contact for all reports
          and enquiries about security issues involving the TOE.
        </title>
      </a-element>
      <a-element type="E">
        <title>
          The evaluator shall confirm that the information provided meets all requirements for content and
          presentation of evidence.</title>
        <aactivity>
          <!-- <TSS> -->
          The evaluator shall inspect the TSS and verify it identifies how to access the flaw remediation procedures.
          <!--</TSS>
				<Guidance> -->
          <h:p>
            The evaluator shall inspect the guidance document and verify it describes how to access the flaw remediation guidance.
          </h:p>
          <!-- </Guidance>--> 
        </aactivity> 
      </a-element>  
    </a-component>
  </section>

  <section id="class-ate" title="Class ATE: Tests">
    Testing is specified for functional aspects of the system as well as aspects that take advantage of design or implementation weaknesses. The former is done through the ATE_IND family, while the latter is through the AVA_VAN family. For this cPP, testing is based on advertised functionality and interfaces with dependency on the availability of design information. One of the primary outputs of the evaluation process is the test report as specified in the following requirements.
    <a-component cc-id="ate_ind.1" name="Independent Testing – Conformance (ATE_IND.1)">
      Testing is performed to confirm the functionality described in the TSS as well as the operational guidance (includes “evaluated configuration” instructions). The focus of the testing is to confirm that the requirements specified in Section 5 are being met. The Evaluation Activities in the SD identify the specific testing activities necessary to verify compliance with the SFRs. The evaluator produces a test report documenting the plan for and results of testing, as well as coverage arguments focused on the platform/TOE combinations that are claiming conformance to this cPP.
      <a-element type="D">
        <title>The developer shall provide the TOE for testing.</title>
        <note role="application">The developer must provide at least one product instance of the TOE for complete testing on at least one
          platform regardless of equivalency. See the Equivalency Appendix for more details.
        </note>
      </a-element>         
      <a-element type="C">
        <title>The TOE shall be suitable for testing.</title>
      </a-element>  
      <a-element type="E">
        <title>The evaluator <h:i>shall confirm</h:i> that the information provided meets all
          requirements for content and presentation of evidence.</title>
      </a-element>
      <a-element type="E">
        <title>The evaluator shall test a subset of the TSF to confirm
          that the TSF operates as specified.</title>
        <note role="application">The evaluator should test the application on the most current
          fully patched version of the platform.</note>
        <aactivity>
          <h:p>
            The evaluator shall prepare a test plan and report documenting the testing
            aspects of the system, including any application crashes during testing. The evaluator
            shall determine the root cause of any application crashes and include that information
            in the report. The test plan covers all of the testing actions contained in
            the <xref to="bibCEM"/> and the body of this PP’s evaluation activities.
          </h:p><h:p>
            While it is not necessary to have one test case per test listed in an evaluation activity, the
            evaluator must document in the test plan that each applicable testing requirement in
            the ST is covered. The test plan identifies the platforms to be tested, and for those
            platforms not included in the test plan but included in the ST, the test plan provides
            a justification for not testing the platforms. This justification must address the
            differences between the tested platforms and the untested platforms, and make an
            argument that the differences do not affect the testing to be performed. It is not
            sufficient to merely assert that the differences have no effect; rationale must be
            provided. If all platforms claimed in the ST are tested, then no rationale is
            necessary. The test plan describes the composition of each platform to be tested, and
            any setup that is necessary beyond what is contained in the AGD documentation. It
            should be noted that the evaluator is expected to follow the AGD documentation for
            installation and setup of each platform either as part of a test or as a standard
            pre-test condition. This may include special test drivers or tools. For each driver or
            tool, an argument (not just an assertion) should be provided that the driver or tool
            will not adversely affect the performance of the functionality by the TOE and its platform.
          </h:p><h:p>
            This also includes the configuration of the
            cryptographic engine to be used. The cryptographic algorithms implemented by this
            engine are those specified by this PP and used by the cryptographic protocols being
            evaluated (e.g., SSH). The test plan identifies high-level test objectives
            as well as the test procedures to be followed to achieve those objectives. These
            procedures include expected results. 
          </h:p><h:p>
            The test report (which could just be an annotated
            version of the test plan) details the activities that took place when the test
            procedures were executed, and includes the actual results of the tests. This shall be
            a cumulative account, so if there was a test run that resulted in a failure; a fix
            installed; and then a successful re-run of the test, the report would show a “fail”
            and “pass” result (and the supporting details), and not just the “pass” result.
          </h:p>
        </aactivity>
      </a-element>
    </a-component>

  </section>
  <section id="class-ava" title="Class AVA: Vulnerability Assessment">
    For the current generation of this cPP, the iTC is expected to survey open sources to discover what vulnerabilities have been 
    discovered in these types of products and provide that content into the AVA_VAN discussion. In most cases, these vulnerabilities
    will require sophistication beyond that of a basic attacker. This information will be used in the development of future Protection
    Profiles.<h:br/><h:br/>
    <comment>Added to address TD0606.</comment><h:br/><h:br/>
    If the TOE is a Network Attached Storage (NAS) device, the evaluator shall verify as part of the vulnerability assessment that 
    remote management services are either not present or can be fully disabled.<h:br/><h:br/>
    
    <a-component cc-id="ava_van.1" name="Vulnerability Survey (AVA_VAN.1)">
      <h:b>Vulnerability Analysis</h:b><h:br/><h:br/>
      <h:b>Sources of Vulnerability Information</h:b><h:br/><h:br/>
        CEM Work Unit AVA_VAN.1-3 is supplemented here to provide a better-defined set of flaws to 
        investigate and procedures to follow based on this particular technology. Terminology used is based on the flaw hypothesis
        methodology, where the evaluation team hypothesizes flaws and then either proves or disproves those flaws (a flaw is equivalent
        to a “potential vulnerability” as used in the CEM). Flaws are categorized into four “types” depending on how they are 
        formulated: <h:ol>
          <h:li>
            A list of flaw hypotheses applicable to the technology described by the cPP derived from public sources as documented in 
            the Type 1 Hypotheses section—this fixed set has been agreed to by the iTC. Additionally, this will be supplemented with entries for a set
            of public sources (as indicated below) that are directly applicable to the TOE or its identified components (as defined by 
            the process in the Type 1 Hypotheses section below); this is to ensure that the evaluators include in their assessment applicable entries 
            that have been discovered since the cPP was published;
          </h:li>
          <h:li>
            A list of flaw hypotheses contained in this document that are derived from lessons learned specific to that technology and
            other iTC input (that might be derived from other open sources and vulnerability databases, for example) as documented in 
            the Type 2 Hypotheses section;
          </h:li>
          <h:li>
            A list of flaw hypotheses derived from information available to the evaluators; this includes the baseline evidence 
            provided by the vendor described in this document (documentation associated with EAs, documentation described in
            the Vulnerability Survey section), as well as other information (public and/or based on evaluator experience) as documented in the Type 3 Hypotheses
            section; and
          </h:li>
          <h:li>
            A list of flaw hypotheses that are generated through the use of iTC-defined tools (e.g., nmap, protocol testers) and their
            application is specified in the Type 4 Hypotheses section.
          </h:li>
        </h:ol>
      <h:b><h:i>Type 1 Hypotheses-Public-Vulnerability-Based</h:i></h:b><h:br/><h:br/>
        The following list of public sources of vulnerability information was selected by the iTC:
        <h:ol type="a">
          <h:li>Search Common Vulnerabilities and Exposures: http://cve.mitre.org/cve/</h:li>
          <h:li>Search the National Vulnerability Database: https://nvd.nist.gov/</h:li>
          <h:li>Search US-CERT: http://www.kb.cert.org/vuls/html/search</h:li>
        </h:ol>
        The list of sources above was searched with the following search terms:
        <h:ul>
          <h:li>General (for all) <h:ul>
            <h:li>Product name</h:li>
            <h:li>Underlying components (e.g., OS, software libraries (crypto libraries), chipsets)</h:li>
            <h:li>Drive encryption, disk encryption</h:li>
            <h:li>Key destruction and sanitization</h:li>
          </h:ul></h:li>          
          <h:li>For Software FDE (AA or EE) <h:ul>
            <h:li>Key caching</h:li>
          </h:ul></h:li></h:ul>
      In order to successfully complete this activity, the evaluator will use the developer provided list of all of third party library
      information that is used as part of their product, along with the version and any other identifying information (this is required
      in the cPP as part of the ASE_TSS.1.1C requirement). This applies to hardware (including chipsets, etc.) that a vendor utilizes 
      as part of their TOE. This TOE-unique information will be used in the search terms the evaluator uses in addition to those listed
      above.<h:br/><h:br/>
      The evaluator will also consider the requirements that are chosen and the appropriate guidance that is tied to each requirement.<h:br/><h:br/>
      In order to supplement this list, the evaluators shall also perform a search on the sources listed above to determine a list of 
      potential flaw hypotheses that are more recent that the publication date of the cPP, and those that are specific to the TOE and
      its components as specified by the additional documentation mentioned above. Any duplicates – either in a specific entry, or in
      the flaw hypothesis that is generated from an entry from the same or a different source – can be noted and removed from 
      consideration by the evaluation team.<h:br/><h:br/>
      As part of type 1 flaw hypothesis generation for the specific components of the TOE, the evaluator shall also search the 
      component manufacturer’s websites to determine if flaw hypotheses can be generated on this basis (for instance, if security 
      patches have been released for the version of the component being evaluated, the subject of those patches may form the basis 
      for a flaw hypothesis).<h:br/><h:br/>
      <h:b><h:i>Type 2 Hypotheses-iTC-Sourced</h:i></h:b><h:br/><h:br/>
      There are no type 2 hypotheses for AA.
      <h:br/><h:br/>
      <h:b><h:i>Type 3 Hypotheses-Evaluation-Team-Generated</h:i></h:b><h:br/><h:br/>
          The iTC has leveraged the expertise of the developers and the evaluation labs to diligently develop the appropriate search
          terms and vulnerability databases. They have also thoughtfully considered the iTC-sourced hypotheses the evaluators should
          use based upon the applicable use case and the threats to be mitigated by the SFRs. Therefore, it is the intent of the iTC,
          for the evaluation to focus all effort on the Type 1 and Type 2 Hypotheses and has decided that Type 3 Hypotheses are not 
          necessary.<h:br/><h:br/>
          However, if the evaluators discover a Type 3 potential flaw that they believe should be considered, they should work with 
          their Certification Body to determine the feasibility of pursuing the hypothesis. The Certification Body may determine 
          whether the potential flaw hypotheses is worth submitting to the iTC for consideration as Type 2 hypotheses in future drafts 
          of the cPP/SD.<h:br/><h:br/>
      <h:b><h:i>Type 4 Hypotheses-Evaluation-Team-Generated</h:i></h:b><h:br/><h:br/>
          The iTC has called out several tools that should be used during the Type 2 hypotheses process. Therefore, the use of any tools
          is covered within the Type 2 construct and the iTC does not see any additional tools that are necessary. The use case for 
          Version 2 of this cPP is rather straightforward – the device is found in a powered down state and has not been subjected to
          revisit/evil maid attacks. Since that is the use case, the iTC has also assumed there is a trusted channel between the AA and
          EE. Since the use case is so narrow, and is not a typical model for penetration or fuzzing testing, the normal types of 
          testing do not apply. Therefore, the relevant types of tools are referenced in Type 2.<h:br/><h:br/>
      <h:b>Process for Evaluator Vulnerability Analysis</h:b><h:br/><h:br/>
          As flaw hypotheses are generated from the activities described above, the evaluation team will disposition them; that is, 
          attempt to prove, disprove, or determine the non-applicability of the hypotheses. This process is as follows.
          The evaluator will refine each flaw hypothesis for the TOE and attempt to disprove it using the information provided by the
          developer or through penetration testing. During this process, the evaluator is free to interact directly with the developer
          to determine if the flaw exists, including requests to the developer for additional evidence (e.g., detailed design 
          information, consultation with engineering staff); however, the CB should be included in these discussions. Should the
          developer object to the information being requested as being not compatible with the overall level of the evaluation 
          activity/cPP and cannot provide evidence otherwise that the flaw is disproved, the evaluator prepares an appropriate set of
          materials as follows:
          <h:ul>
            <h:li>The source documents used in formulating the hypothesis, and why it represents a potential compromise against a 
              specific TOE function;</h:li>
            <h:li>An argument why the flaw hypothesis could not be proven or disproved by the evidence provided so far; and</h:li>
            <h:li>The type of information required to investigate the flaw hypothesis further.</h:li>
          </h:ul>
          The Certification Body (CB) will then either approve or disapprove the request for additional information. If approved, the
          developer provides the requested evidence to disprove the flaw hypothesis (or, of course, acknowledge the flaw).<h:br/><h:br/>
          For each hypothesis, the evaluator will note whether the flaw hypothesis has been successfully disproved, successfully proven
          to have identified a flaw, or requires further investigation. It is important to have the results documented as outlined in 
          the Reporting section below.
          If the evaluator finds a flaw, the evaluator must report these flaws to the developer. All reported flaws must be addressed 
          as follows:<h:br/><h:br/>
          If the developer confirms that the flaw exists and that it is exploitable at Basic Attack Potential, then a change is made by
          the developer, and the resulting resolution is agreed by the evaluator and noted as part of the evaluation report.<h:br/><h:br/>
          If the developer, the evaluator, and the CB agree that the flaw is exploitable only above Basic Attack Potential and does not 
          require resolution for any other reason, then no change is made and the flaw is noted as a residual vulnerability in the 
          CB-internal report (ETR).<h:br/><h:br/>
          If the developer and evaluator agree that the flaw is exploitable only above Basic Attack Potential, but it is deemed critical
          to fix because of technology-specific or cPP-specific aspects such as typical use cases or operational environments, then a 
          change is made by the developer, and the resulting resolution is agreed by the evaluator and noted as part of the evaluation
          report.<h:br/><h:br/>
          Disagreements between evaluator and vendor regarding questions of the existence of a flaw, its attack potential, or whether
          it should be deemed critical to fix are resolved by the CB.<h:br/><h:br/>
          Any testing performed by the evaluator shall be documented in the test report as outlined
          in the Reporting section below.<h:br/><h:br/>
          As indicated in the Reporting section, the public statement with respect to vulnerability analysis that is performed on TOEs 
          conformant to the cPP is constrained to coverage of flaws associated with Types 1 and 2 (defined in the Sources of 
          Vulnerability Information section) flaw hypotheses only. The fact that the iTC generates these candidate hypotheses indicates 
          these must be addressed.<h:br/><h:br/>
      <h:b>Reporting</h:b><h:br/><h:br/>
          The evaluators shall produce two reports on the testing effort; one that is public-facing (that is, included in the 
          non-proprietary evaluation report, which is a subset of the Evaluation Technical Report (ETR)), and the complete ETR that is 
          delivered to the overseeing CB.<h:br/><h:br/>
          The public-facing report contains:<h:ul>
          <h:li>The flaw identifiers returned when the procedures for searching public sources were followed according to instructions in
            the Type 1 Hypotheses section;</h:li>
            <h:li>A statement that the evaluators have examined the Type 1 flaw hypotheses specified
              in this document in the 
              Type 1 Hypotheses section (i.e. the flaws listed in the previous bullet) and the Type 2 flaw hypotheses specified in the 
              the Type 2 Hypotheses section</h:li>
          </h:ul>
          No other information is provided in the public-facing report.<h:br/><h:br/>
          The internal CB report contains, in addition to the information in the public-facing report:<h:ul>
            <h:li>a list of all of the flaw hypotheses generated (cf. AVA_VAN.1-4);</h:li>
            <h:li>the evaluator penetration testing effort, outlining the testing approach, configuration, depth and results (cf. 
              AVA_VAN.1-9);</h:li>
            <h:li>all documentation used to generate the flaw hypotheses (in identifying the documentation used in coming up with the
              flaw hypotheses, the evaluation team must characterize the documentation so that a reader can determine whether it is 
              strictly required in this document, and the nature of the documentation (design information, developer 
              engineering notebooks, etc.));</h:li>
            <h:li>the evaluator shall report all exploitable vulnerabilities and residual vulnerabilities, detailing for each:
              <h:ol type="a">
              <h:li>its source (e.g. CEM activity being undertaken when it was conceived, known to the evaluator, read in a publication)</h:li>
              <h:li>the SFRs not met;</h:li>
              <h:li>a description;</h:li>
              <h:li>whether it is exploitable in its operational environment or not (i.e. exploitable or residual).</h:li>
              <h:li>the amount of time, level of expertise, level of knowledge of the TOE, level of opportunity and the equipment 
                required to perform the identified vulnerabilities (cf. AVA_VAN.1-11);</h:li>
              <h:li>how each flaw hypothesis was resolved (this includes whether the original flaw hypothesis was confirmed or 
                disproved, and any analysis relating to whether a residual vulnerability is exploitable by an attacker with Basic
                Attack Potential) (cf. AVA_VAN1-10); and</h:li>
              <h:li>in the case that actual testing was performed in the investigation (either as part of flaw hypothesis generation
                using tools specified by the iTC in the Type 4 Hypotheses section, or in proving or disproving a particular flaw) the steps followed in
                setting up the TOE (and any required test equipment); executing the test; post-test procedures; and the actual results
                (to a level of detail that allow repetition of the test, including the following:<h:ul>
              <h:li>identification of the potential vulnerability the TOE is being tested for;</h:li>
              <h:li>instructions to connect and setup all required test equipment as required to conduct the penetration test;</h:li>
              <h:li>instructions to establish all penetration test prerequisite initial conditions;</h:li>
              <h:li>instructions to stimulate the TSF;</h:li>
              <h:li>instructions for observing the behaviour of the TSF;</h:li>
              <h:li>descriptions of all expected results and the necessary analysis to be performed on the observed behaviour for comparison against expected results;</h:li>
              <h:li>instructions to conclude the test and establish the necessary post-test state for the TOE. (cf. AVA_VAN.1-6, AVA_VAN.1-8).</h:li>
                </h:ul>
              </h:li>
              </h:ol>
            </h:li>
          </h:ul>
          
      <a-element type="D">
        <title>The developer shall provide the TOE for testing.</title>
      </a-element>	
      <a-element type="C">
        <title>The application shall be suitable for testing.</title>
        <note role="application">Suitability for testing means not being obfuscated or
          packaged in such a way as to disrupt either static or dynamic analysis by the
          evaluator.</note>
      </a-element>  
      <a-element type="E">
        <title>The evaluator shall confirm that the information provided meets all requirements
          for content and presentation of evidence.</title>
      </a-element>
      <a-element type="E">
        <title>The evaluator shall perform a search of public domain sources to identify
          potential vulnerabilities in the TOE.</title>
        <note role="application">Public domain sources include the Common Vulnerabilities 
          and Exposures (CVE) dictionary for publicly known vulnerabilities.  Public domain
          sources also include sites which provide free checking of files for viruses.</note>
        <!-- their Usage statement does not permit us to mention VirusTotal by name without permission -->
      </a-element>
      <a-element type="E">
        <title>The evaluator shall conduct penetration testing, based on the identified
          potential vulnerabilities, to determine that the TOE is resistant to
          attacks performed by an attacker possessing Basic attack potential.</title>
        <aactivity>
          <h:p>
            The evaluator shall generate a report to document their findings with respect to this 
            requirement. This report could physically be part of the overall test report mentioned in
            ATE_IND, or a separate document. The evaluator performs a search of public information to find
            vulnerabilities that have been found in similar applications with a particular focus on network 
            protocols the application uses and document formats it parses.
          </h:p><h:p>
            The evaluator documents the sources consulted and the vulnerabilities found in the report.
          </h:p><h:p>
            For each vulnerability found, the evaluator either provides a rationale with respect to its 
            non-applicability, or the evaluator formulates a test (using the guidelines provided in ATE_IND)
            to confirm the vulnerability, if suitable. Suitability is determined by assessing the attack 
            vector needed to take advantage of the vulnerability. If exploiting the vulnerability requires
            expert skills and an electron microscope, for instance, then a test would not be suitable and 
            an appropriate justification would be formulated.
          </h:p>
          <h:div>
            <depends ref="windows"/>
            <depends ref="linux"/>
            <depends ref="mac"/>
            <depends ref="Solaris"/>	
            The evaluator shall also run a virus scanner with the most current virus definitions against the 
            application files and verify that no files are flagged as malicious.
          </h:div>
        </aactivity>
      </a-element>     
    </a-component>
  </section>
  </section>
  
</sec:Security_Requirements>   
<!-- Appendix A includes optional, objective, and implementation-dependent requirements -->
<!-- Appendix B is selection-based requirements -->
<!-- Appendix C: Extended Component Definitions -->
<appendix id="apndx-entropy" title="Entropy Documentation and Assessment">
  <h:p><h:i>This is an optional appendix in the cPP, and only applies if the TOE is providing deterministic random bit generation services, e.g. the ST claims FCS_RBG.1.</h:i></h:p>
  <h:p>This appendix describes the required supplementary information for each entropy source used by the TOE.</h:p>
  <h:p>The documentation of the entropy sources should be detailed enough that, after reading, the evaluator will thoroughly understand the entropy source and why it can be relied upon to provide sufficient entropy. This documentation should include multiple detailed sections: design description, entropy justification, operating conditions, and health testing. This documentation is not required to be part of the TSS in the public facing ST. 
    </h:p>
    <section id="sec-ent-design" title="Design Description">
      <h:p>Documentation shall include the design of each entropy source as a whole, including the interaction of all entropy source components. Any information that can be shared regarding the design should also be included for any third-party entropy sources that are included in the product. </h:p>
      <h:p>The documentation will describe the operation of the entropy source to include how entropy is produced, and how unprocessed (raw) data can be obtained from within the entropy source for testing purposes. The documentation should walk through the entropy source design indicating where the entropy comes from, where the entropy output is passed next, any post-processing of the raw outputs (hash, XOR, etc.), if/where it is stored, and finally, how it is output from the entropy source. Any conditions placed on the process (e.g., blocking) should also be described in the entropy source design. Diagrams and examples are encouraged.</h:p>
      <h:p>This design must also include a description of the content of the security boundary of the entropy source and a description of how the security boundary ensures that an adversary outside the boundary cannot affect the entropy rate.</h:p>
      <h:p>If implemented, the design description shall include a description of how third-party applications can add entropy to the RBG. A description of any RBG state saving between power-off and power-on shall be included.</h:p>
    </section>
    <section id="sec-ent-justification" title="Entropy Justification">
      <h:p>There should be a technical argument for where the unpredictability in the source comes from and why there is confidence in the entropy source delivering sufficient entropy for the uses made of the RBG output (by this particular TOE). This argument will include a description of the expected min-entropy rate (i.e. the minimum entropy (in bits) per bit or byte of source data) and explain that sufficient entropy is going into the TOE randomizer seeding process. This discussion will be part of a justification for why the entropy source can be relied upon to produce bits with entropy.</h:p>
      <h:p>The amount of information necessary to justify the expected min-entropy rate depends on the type of entropy source included in the product.</h:p>
      <h:p>For developer provided entropy sources, in order to justify the min-entropy rate, it is expected that a large number of raw source bits will be collected, statistical tests will be performed, and the min-entropy rate determined from the statistical tests. While no particular statistical tests are required at this time, it is expected that some testing is necessary in order to determine the amount of min-entropy in each output. </h:p>
      <h:p>For third party provided entropy sources, in which the TOE vendor has limited access to the design and raw entropy data of the source, the documentation will indicate an estimate of the amount of min-entropy obtained from this third-party source. It is acceptable for the vendor to “assume” an amount of min-entropy, however, this assumption must be clearly stated in the documentation provided. In particular, the min-entropy estimate must be specified and the assumption included in the ST.</h:p>
      <h:p>Regardless of type of entropy source, the justification will also include how the DRBG is initialized with the entropy stated in the ST, for example by verifying that the min-entropy rate is multiplied by the amount of source data used to seed the DRBG or that the rate of entropy expected based on the amount of source data is explicitly stated and compared to the statistical rate. If the amount of source data used to seed the DRBG is not clear or the calculated rate is not explicitly related to the seed, the documentation will not be considered complete.</h:p>
      <h:p>The entropy justification shall not include any data added from any third-party application or from any state saving between restarts.</h:p>
    </section>
    <section id="sec-ent-oc" title="Operating Conditions">The entropy rate may be affected by conditions outside the control of the entropy source itself. For example, voltage, frequency, temperature, and elapsed time after power-on are just a few of the factors that may affect the operation of the entropy source. As such, documentation will also include the range of operating conditions under which the entropy source is expected to generate random data. Similarly, documentation shall describe the conditions under which the entropy source is no longer guaranteed to provide sufficient entropy. Methods used to detect failure or degradation of the source shall be included.</section>
    <section id="s-ent-health" title="Health Testing">More specifically, all entropy source health tests and their rationale will be documented. This will include a description of the health tests, the rate and conditions under which each health test is performed (e.g., at startup, continuously, or on-demand), the expected results for each health test, TOE behavior upon entropy source failure, and rationale indicating why each test is believed to be appropriate for detecting one or more failures in the entropy source.</section>
</appendix>
<appendix id="apndx-keyMan" title="Key Management Description">
  <h:p>The documentation of the product’s encryption key management should be detailed enough that, after reading, the evaluator will thoroughly understand the product’s key management and how it meets the requirements to ensure the keys are adequately protected. This documentation should include an essay and diagrams. This documentation is not required to be part of the TSS - it can be submitted as a separate document and marked as developer proprietary.</h:p>
  <h:p>Essay:</h:p>
  <h:p>The essay will provide the following information for all keys in the key chain:</h:p>
  <h:p><h:ul>
    <h:li>The purpose of the key</h:li>
    <h:li>If the key is stored in non-volatile memory</h:li>
    <h:li>How and when the key is protected</h:li>
    <h:li>How and when the key is derived</h:li>
    <h:li>The strength of the key</h:li>
    <h:li>When or if the key would be no longer needed, along with a justification.</h:li>
  </h:ul>The essay will also describe the following topics:</h:p>
  <h:p><h:ul>
    <h:li>A description of all authorization factors that are supported by the product and how each factor is handled, including any conditioning and combining performed.</h:li>
    <h:li>If validation is supported, the process for validation shall be described, noting what value is used for validation and the process used to perform the validation. It shall describe how this process ensures no keys in the key chain are weakened or exposed by this process.</h:li>
    <h:li>The authorization process that leads to the ultimate release of the BEV. This section shall detail the key chain used by the product. It shall describe which keys are used in the protection of the BEV and how they meet the derivation, key wrap, or a combination of the two requirements, including the direct chain from the initial authorization to the BEV. It shall also include any values that add into that key chain or interact with the key chain and the protections that ensure those values do not weaken or expose the overall strength of the key chain.</h:li>
    <h:li>The diagram and essay will clearly illustrate the key hierarchy to ensure that at no point the chain could be broken without a cryptographic exhaust or all of the initial authorization values and the effective strength of the BEV is maintained throughout the Key Chain. 
      </h:li>
    <h:li>A description of the data encryption engine, its components, and details about its implementation (e.g. for hardware: integrated within the device’s main SOC or separate co-processor, for software: initialization of the product, drivers, libraries (if applicable), logical interfaces for encryption/decryption, and areas which are not encrypted (e.g. boot loaders, portions associated with the Master Boot Record (MBRs), partition tables, etc.)). The description should also include the data flow from the device’s host interface to the device’s persistent media storing the data, information on those conditions in which the data bypasses the data encryption engine (e.g. read-write operations to an unencrypted Master Boot Record area). The description should be detailed enough to verify all platforms to ensure that when the user enables encryption, the product encrypts all hard storage devices. It should also describe the platform’s boot initialization, the encryption initialization process, and at what moment the product enables the encryption.</h:li>
    <h:li>The process for destroying keys when they are no longer needed by describing the storage location of all keys and the protection of all keys stored in non-volatile memory.</h:li>

  </h:ul></h:p>
  <h:p>Diagram:
  </h:p>
  <h:p>
    <h:ul>
      <h:li>The diagram will include all keys from the initial authorization factors to the BEV and any keys or values that contribute into the chain. It must list the cryptographic strength of each key and indicate how each key along the chain is protected with either Key Derivation or Key Wrapping (from the allowed options). The diagram should indicate the input used to derive or unwrap each key in the chain.</h:li>
      <h:li>A functional (block) diagram showing the main components (such as memories and processors) and the data path between, for hardware, the device’s host interface and the device’s persistent media storing the data, or for software, the initial steps needed for the activities the TOE performs to ensure it encrypts the storage device entirely when a user or administrator first provisions the product. The hardware encryption diagram shall show the location of the data encryption engine within the data path.</h:li>
      <h:li>The hardware encryption diagram shall show the location of the data encryption engine within the data path. The evaluator shall validate that the hardware encryption diagram contains enough detail showing the main components within the data path and that it clearly identifies the data encryption engine. </h:li>
    </h:ul>
  </h:p>

</appendix>
<!-- Appendix D: Implicity Satisfied Requirements -->
<!-- Appendix G: Use-Case Templates -->
<!-- Appendix H: Acronyms -->
<!-- Appendix I: Bibliography -->

<bibliography>
<!--	  <cc-entry/>   -->
<cc-entry/>
<entry id="bibfdeiee">
    <tag>FDE–EE</tag>
    
    <description>
        <!-- todo: update hyperlink when PP published -->
        <h:a href="https://commoncriteria.github.io/FDEEE/master/FDEEE-release.html">collaborative Protection Profile for Full Drive Encryption – Encryption Engine, Version 2.1,
          MMMM DD, 2025</h:a><comment>Adjust date once finalized</comment></description> 
</entry>
 </bibliography>

</PP>
